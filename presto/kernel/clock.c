////////////////////////////////////////////////////////////////////////////////
//   C O M M E N T A R Y
////////////////////////////////////////////////////////////////////////////////

// These functions define a simple clock interface.  I need a way to keep
// track of some very long running numbers.  Rather than use a "long long",
// I just use a structure with some easily-understood components.  There's
// just a few functions, mainly add and compare.

// Eventually, I would like to add some sort of subtract function, or maybe
// try to use a compiler-supported data type (like long long).  But when I
// use even 32-bit longs, the O/S crashes.  I'm not sure if the long math
// functions are re-entrant?

// These will do for now.

////////////////////////////////////////////////////////////////////////////////
//   D E P E N D E N C I E S
////////////////////////////////////////////////////////////////////////////////

#include "types.h"
#include "kernel/clock.h"

////////////////////////////////////////////////////////////////////////////////
//   S T A T I C   F U N C T I O N S
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   E X P O R T E D   F U N C T I O N S
////////////////////////////////////////////////////////////////////////////////

void clock_reset(KERNEL_TIME_T * clk) {
   clk->t[0]=0;
   clk->t[1]=0;
   clk->t[2]=0;
}

////////////////////////////////////////////////////////////////////////////////

void clock_add_ms(KERNEL_TIME_T * clk, unsigned short ms) {
   unsigned short was;
   was=clk->t[0];
   clk->t[0]+=ms;
   if ((clk->t[0]<was)||(clk->t[0]<ms)) {
      clk->t[1]++;
      if (clk->t[1]==0) {
         clk->t[2]++;
      }
   }
}

////////////////////////////////////////////////////////////////////////////////

void clock_add_sec(KERNEL_TIME_T * clk, unsigned short s) {
}

////////////////////////////////////////////////////////////////////////////////

signed char clock_compare(KERNEL_TIME_T * A,KERNEL_TIME_T * B) {
   int x;
   x=3;
   do {
      x--;
      if (A->t[x] < B->t[x]) return -1;
      if (A->t[x] > B->t[x]) return 1;
   } while (x>0);
   return 0;
}

////////////////////////////////////////////////////////////////////////////////


