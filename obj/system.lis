                         .area memory(abs)
                         .org 0xffd6
 FFD6                 _normal_interrupt_vectors::
 FFD6 00A1              .word _inert_isr
 FFD8 00A1              .word _inert_isr
 FFDA 00A1              .word _inert_isr
 FFDC 00A1              .word _inert_isr
 FFDE 00A1              .word _inert_isr
 FFE0 00A1              .word _inert_isr
 FFE2 00A1              .word _inert_isr
 FFE4 00A1              .word _inert_isr
 FFE6 00A1              .word _inert_isr
 FFE8 00A1              .word _inert_isr
 FFEA 00A1              .word _inert_isr
 FFEC 00A1              .word _inert_isr
 FFEE 00A1              .word _inert_isr
 FFF0 00A1              .word _inert_isr
 FFF2 00A1              .word _inert_isr
 FFF4 00A1              .word _inert_isr
 FFF6 00A1              .word _inert_isr
 FFF8 00A1              .word _inert_isr
 FFFA 00A1              .word _inert_isr
 FFFC 00A1              .word _inert_isr
 FFFE 0000              .word __start
                         .area data
                         .area text
                       ;  IX -> 0,x
 0000                 __HC11Setup::
 0000 0F                    sei
 0001                 system.92::	
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   C O M M E N T A R Y
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   D E P E N D E N C I E S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #include "hc11regs.h"
                       ; #include "system.h"
                       ; #include "kernel\kernel.h"
                       ; //#include "services\serial.h"
                       ; //#include "services\motors.h"
                       ; //#include "services\sound.h"
                       ; 
                       ; // ICC only
                       ; extern void _start();   // entry point in crt11.s
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   C O N S T A N T S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   D A T A   T Y P E S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   S T A T I C   F U N C T I O N   P R O T O T Y P E S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #pragma interrupt presto_swi
                       ; void presto_swi(void);
                       ; 
                       ; #pragma interrupt inert_isr
                       ; void inert_isr(void);
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   S T A T I C   G L O B A L   D A T A
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // INTERRUPT VECTORS
                       ; 
                       ; 
                       ; #pragma abs_address:0xFFD6 // for NORMAL and EXPANDED MULTIPLEXED modes
                       ; void (*normal_interrupt_vectors[])() = {
                       ;    inert_isr,   // SCI    -   presto_serial_isr
                       ;    inert_isr,   // SPI
                       ;    inert_isr,   // PAIE
                       ;    inert_isr,   // PAO
                       ;    inert_isr,   // TOF
                       ;    inert_isr,   // TOC5
                       ;    inert_isr,   // TOC4
                       ;    inert_isr,   // TOC3   -   motor_isr
                       ;    inert_isr,   // TOC2   -   presto_system_isr
                       ;    inert_isr,   // TOC1
                       ;    inert_isr,   // TIC3
                       ;    inert_isr,   // TIC2
                       ;    inert_isr,   // TIC1
                       ;    inert_isr,   // RTI
                       ;    inert_isr,   // IRQ
                       ;    inert_isr,   // XIRQ
                       ;    inert_isr,   // SWI
                       ;    inert_isr,   // ILLOP
                       ;    inert_isr,   // COP
                       ;    inert_isr,   // CLM
                       ;    _start       // RESET
                       ; };
                       ; #pragma end_abs_address
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   E X P O R T E D   F U N C T I O N S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   S T A T I C   F U N C T I O N S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // This function is called from the startup (crt11.s) before interrupts have
                       ; // been turned on but after the stack has been set up.
                       ; 
                       ; void _HC11Setup() {
                       ; 
                       ;    INTR_OFF();
                       ; 
                       ;    // disable output compare interrupts for TOC1,TOC2,TOC3,TOC4,TOC5
                       ;    // disable input capture interrupts for TIC1,TIC2,TIC3
                       ;    TMSK1=0x00;
 0001 7F1022            clr 0x1022
 0004                 system.96::	
                       ; 
                       ;    // set prescaler for timer to 1
                       ;    // disable TOF, RTIF, PAOVF, PAIF interrupts
                       ;    TMSK2=0x00;
 0004 7F1024            clr 0x1024
 0007                 system.99::	
                       ; 
                       ;    // disable SPI subsystem, disable SPI interrupt
                       ;    SPCR=0x04;
 0007 C604              ldab #4
 0009 F71028            stab 0x1028
 000C                 system.102::	
                       ; 
                       ;    // disable all serial interrupts
                       ;    SCCR2=0x00;
 000C 7F102D            clr 0x102d
 000F                 system.105::	
                       ; 
                       ;    // disable parallel I/O (and strobe A interrupt)
                       ;    PIOC=0x00;
 000F 7F1002            clr 0x1002
 0012                 system.108::	
                       ; 
                       ;    // disable SECURITY and COP, disable ROM and EEPROM
                       ;    CONFIG=0x0C;
 0012 C60C              ldab #12
 0014 F7103F            stab 0x103f
 0017                 system.113::	
                       ; 
                       ;    // turn on the A2D subsystem (wait 100 usec before using)
                       ;    // use "E clock" to drive the A2D
                       ;    // disable COP clock monitor (interrupt)
                       ;    OPTION=0xA0;  // OPTION_ADPU=1,OPTION_CSEL=0
 0017 C6A0              ldab #160
 0019 F71039            stab 0x1039
 001C                 system.115::	
                       ; 
                       ;    normal_interrupt_vectors[INTR_SCI]=  inert_isr;
 001C CC00A1            ldd #_inert_isr
 001F FDFFD6            std _normal_interrupt_vectors
 0022                 system.116::	
                       ;    normal_interrupt_vectors[INTR_SPI]=  inert_isr;
 0022 CC00A1            ldd #_inert_isr
 0025 FDFFD8            std _normal_interrupt_vectors+2
 0028                 system.117::	
                       ;    normal_interrupt_vectors[INTR_PAIE]= inert_isr;
 0028 CC00A1            ldd #_inert_isr
 002B FDFFDA            std _normal_interrupt_vectors+4
 002E                 system.118::	
                       ;    normal_interrupt_vectors[INTR_PAO]=  inert_isr;
 002E CC00A1            ldd #_inert_isr
 0031 FDFFDC            std _normal_interrupt_vectors+6
 0034                 system.119::	
                       ;    normal_interrupt_vectors[INTR_TOF]=  inert_isr;
 0034 CC00A1            ldd #_inert_isr
 0037 FDFFDE            std _normal_interrupt_vectors+8
 003A                 system.120::	
                       ;    normal_interrupt_vectors[INTR_TOC5]= inert_isr;
 003A CC00A1            ldd #_inert_isr
 003D FDFFE0            std _normal_interrupt_vectors+10
 0040                 system.121::	
                       ;    normal_interrupt_vectors[INTR_TOC4]= inert_isr;
 0040 CC00A1            ldd #_inert_isr
 0043 FDFFE2            std _normal_interrupt_vectors+12
 0046                 system.122::	
                       ;    normal_interrupt_vectors[INTR_TOC3]= inert_isr;
 0046 CC00A1            ldd #_inert_isr
 0049 FDFFE4            std _normal_interrupt_vectors+14
 004C                 system.123::	
                       ;    normal_interrupt_vectors[INTR_TOC2]= inert_isr;
 004C CC00A1            ldd #_inert_isr
 004F FDFFE6            std _normal_interrupt_vectors+16
 0052                 system.124::	
                       ;    normal_interrupt_vectors[INTR_TOC1]= inert_isr;
 0052 CC00A1            ldd #_inert_isr
 0055 FDFFE8            std _normal_interrupt_vectors+18
 0058                 system.125::	
                       ;    normal_interrupt_vectors[INTR_TIC3]= inert_isr;
 0058 CC00A1            ldd #_inert_isr
 005B FDFFEA            std _normal_interrupt_vectors+20
 005E                 system.126::	
                       ;    normal_interrupt_vectors[INTR_TIC2]= inert_isr;
 005E CC00A1            ldd #_inert_isr
 0061 FDFFEC            std _normal_interrupt_vectors+22
 0064                 system.127::	
                       ;    normal_interrupt_vectors[INTR_TIC1]= inert_isr;
 0064 CC00A1            ldd #_inert_isr
 0067 FDFFEE            std _normal_interrupt_vectors+24
 006A                 system.128::	
                       ;    normal_interrupt_vectors[INTR_RTI]=  inert_isr;
 006A CC00A1            ldd #_inert_isr
 006D FDFFF0            std _normal_interrupt_vectors+26
 0070                 system.129::	
                       ;    normal_interrupt_vectors[INTR_IRQ]=  inert_isr;
 0070 CC00A1            ldd #_inert_isr
 0073 FDFFF2            std _normal_interrupt_vectors+28
 0076                 system.130::	
                       ;    normal_interrupt_vectors[INTR_XIRQ]= inert_isr;
 0076 CC00A1            ldd #_inert_isr
 0079 FDFFF4            std _normal_interrupt_vectors+30
 007C                 system.131::	
                       ;    normal_interrupt_vectors[INTR_SWI]=  inert_isr;
 007C CC00A1            ldd #_inert_isr
 007F FDFFF6            std _normal_interrupt_vectors+32
 0082                 system.132::	
                       ;    normal_interrupt_vectors[INTR_ILLOP]=presto_fatal_error;
 0082 CC00CA            ldd #_presto_fatal_error
 0085 FDFFF8            std _normal_interrupt_vectors+34
 0088                 system.133::	
                       ;    normal_interrupt_vectors[INTR_COP]=  inert_isr;
 0088 CC00A1            ldd #_inert_isr
 008B FDFFFA            std _normal_interrupt_vectors+36
 008E                 system.134::	
                       ;    normal_interrupt_vectors[INTR_CLM]=  inert_isr;
 008E CC00A1            ldd #_inert_isr
 0091 FDFFFC            std _normal_interrupt_vectors+38
 0094                 system.135::	
                       ;    normal_interrupt_vectors[INTR_RESET]=_start;
 0094 CC0000            ldd #__start
 0097 FDFFFE            std _normal_interrupt_vectors+40
 009A                 system.140::	
                       ; 
                       ;    // get out of SPECIAL TEST operating mode
                       ;    // go into EXPANDED MULTIPLEXED operating mode
                       ;    // promote IRQ interrupt priority
                       ;    HPRIO=0x25;
 009A C625              ldab #37
 009C F7103C            stab 0x103c
 009F 0E                    cli
 00A0                 system.143::	
                       ; 
                       ;    INTR_ON();
                       ; }
 00A0                 L11:
 00A0 39                rts
                       ;  IX -> 0,x
 00A1                 _inert_isr::
 00A1                 system.149::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #pragma interrupt inert_isr
                       ; void inert_isr(void) {
                       ; }
 00A1                 L32:
 00A1 39                rts
                       ;  IX -> 0,x
                       ;         vector -> 8,x
                       ;           intr -> 5,x
 00A2                 _set_interrupt::
 00A2 37                pshb
 00A3 36                psha
 00A4 3C                pshx
 00A5 30                tsx
 00A6 3C                pshx
 00A7 30                tsx
 00A8 EC04              ldd 4,x
 00AA E705              stab 5,x
 00AC                 system.155::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; //extern void os_set_irq(int number, void (*fn)() );
                       ; void set_interrupt(BYTE intr, void (*vector)(void)) {
                       ;    if(intr<=INTR_RESET) {
 00AC E605              ldab 5,x
 00AE C114              cmpb #20
 00B0 220E              bhi L34
 00B2                 system.156::	
                       ;       normal_interrupt_vectors[intr]=vector;
 00B2 E605              ldab 5,x
 00B4 4F                clra
 00B5 05                lsld
 00B6 C3FFD6            addd #_normal_interrupt_vectors
 00B9 188F              xgdy
 00BB EC08              ldd 8,x
 00BD 18ED00            std 0,y
 00C0                 system.157::	
                       ;    }
 00C0                 L34:
 00C0                 system.158::	
                       ; }
 00C0                 L33:
 00C0 8F                xgdx
 00C1 C30002            addd #2
 00C4 8F                xgdx
 00C5 35                txs
 00C6 38                pulx
 00C7 1838              puly
 00C9 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          delay -> 3,x
 00CA                 _presto_fatal_error::
 00CA BD0000            jsr __enterb
 00CD 04                .byte 0x4
 00CE 0F                    sei
 00CF 8E0000            lds #init_sp
 00D2                 system.176::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   S A F E T Y   C H E C K
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // this is the memory location for the motor controller
                       ; #define ERROR_PORT *(unsigned char *)(0x7FFF)
                       ; 
                       ; void presto_fatal_error(void) {
                       ;    // should never get here
                       ;    BYTE delay;
                       ;    INTR_OFF();
                       ; 
                       ;    // reload the original stack pointer, so we don't trash anything else
                       ;    asm("lds #init_sp");
                       ; 
                       ;    // speaker is always an output
                       ;    BITSET(DDRD,4);              // LED is an output
 00D2 18CE1009          ldy #0x1009
 00D6 181C0010          bset 0,y,#16
 00DA 202A              bra L38
 00DC                 L37:
 00DC                 system.179::	
                       ;    while(1) {
                       ;       // toggle speaker
                       ;       BITNOT(PORTA,3);
 00DC F61000            ldab 0x1000 ; vol
 00DF 4F                clra
 00E0 8800              eora #0
 00E2 C808              eorb #8
 00E4 F71000            stab 0x1000
 00E7                 system.181::	
                       ;       // LED on
                       ;       BITCLR(PORTD,4);
 00E7 18CE1008          ldy #0x1008
 00EB 181D0010          bclr 0,y,~#-17
 00EF 2005              bra L41
 00F1                 L40:
 00F1                 system.186::	
                       ;       // delay
                       ;       while(--delay>0) {
                       ;          // This will force the motor lights to blink so fast
                       ;          // that all eight of them will appear to be on.
                       ;          ERROR_PORT=delay;
 00F1 E603              ldab 3,x
 00F3 F77FFF            stab 0x7fff
 00F6                 system.187::	
                       ;       }
 00F6                 L41:
 00F6 E603              ldab 3,x
 00F8 4F                clra
 00F9 830001            subd #1
 00FC E702              stab 2,x
 00FE E703              stab 3,x
 0100 E602              ldab 2,x
 0102 C100              cmpb #0
 0104 22EB              bhi L40
 0106                 system.188::	
                       ;    }
 0106                 L38:
 0106 20D4              bra L37
 0108                 L36:
 0108 8F                xgdx
 0109 C30004            addd #4
 010C 8F                xgdx
 010D 35                txs
 010E 38                pulx
 010F 39                rts
