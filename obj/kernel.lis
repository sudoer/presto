                         .area data
 0000                 _global_new_sp::
 0000                   .blkb 2
                         .area idata
 0000 0000              .word 0
                         .area data
 0002                 _global_old_sp_p::
 0002                   .blkb 2
                         .area idata
 0002 0000              .word 0
                         .area data
 0004                 _global_new_fn::
 0004                   .blkb 2
                         .area idata
 0004 0000              .word 0
                         .area data
 0006                 _current_tcb_p::
 0006                   .blkb 2
                         .area idata
 0006 0000              .word 0
                         .area data
 0008                 _current_tid::
 0008                   .blkb 1
                         .area idata
 0008 00                .byte 0
                         .area data
 0009                 _tcb_head_p::
 0009                   .blkb 2
                         .area idata
 0009 0000              .word 0
                         .area data
 000B                 _free_tcb_p::
 000B                   .blkb 2
                         .area idata
 000B 0000              .word 0
                         .area data
 000D                 _presto_initialized::
 000D                   .blkb 1
                         .area idata
 000D 00                .byte 0
                         .area data
 000E                 _free_mail_p::
 000E                   .blkb 2
                         .area idata
 000E 0000              .word 0
                         .area data
 0010                 _po_mail_p::
 0010                   .blkb 2
                         .area idata
 0010 0000              .word 0
                         .area text
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
                       ;          count -> 7,x
 0000                 _presto_init::
 0000 BD0000            jsr __enterb
 0003 08                .byte 0x8
 0004                 kernel.80::	
                       ; 
                       ; #include "hc11regs.h"
                       ; #include "system.h"
                       ; #include "presto.h"
                       ; #include "kernel\kernel.h"
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #define CYCLES_PER_MS     2000
                       ; #define MS_PER_TICK       100
                       ; #define CYCLES_PER_TICK   CYCLES_PER_MS*MS_PER_TICK
                       ; #define IDLE_PRIORITY     0
                       ; #define IDLE_STACK_SIZE   50
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #define DISABLE_CCR_INTERRUPT_BIT      asm("oraa #0x10");
                       ; #define ENABLE_CCR_INTERRUPT_BIT      asm("anda ~#0x10");
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // GLOBAL VARIABLES
                       ; // These are used to pass arguments to inline assembly routines
                       ; 
                       ; /*static*/ BYTE * global_new_sp=NULL;
                       ; /*static*/ BYTE ** global_old_sp_p=NULL;
                       ; /*static*/ void (*global_new_fn)(void)=NULL;
                       ; /*static*/ BYTE * global_save_sp;     // do not put this on the stack (BOOM)
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // STATIC GLOBAL VARIABLES
                       ; 
                       ; /*static*/ PRESTO_TCB_T * current_tcb_p=NULL;
                       ; /*static*/ PRESTO_TID_T current_tid=0;
                       ; /*static*/ PRESTO_TCB_T * tcb_head_p=NULL;
                       ; /*static*/ PRESTO_TCB_T * free_tcb_p=NULL;
                       ; /*static*/ PRESTO_TCB_T tcb_list[MAX_TASKS];
                       ; 
                       ; /*static*/ PRESTO_TIME_T presto_master_clock;
                       ; /*static*/ BYTE presto_initialized=0;
                       ; 
                       ; // idle task stuff
                       ; /*static*/ BYTE idle_stack[IDLE_STACK_SIZE];
                       ; /*static*/ PRESTO_TCB_T * idle_tcb_p;
                       ; /*static*/ BYTE idle_tid;
                       ; 
                       ; // mail stuff
                       ; /*static*/ PRESTO_MESSAGE_T * free_mail_p=NULL;
                       ; /*static*/ PRESTO_MESSAGE_T * po_mail_p=NULL;
                       ; /*static*/ PRESTO_MESSAGE_T mail_list[MAX_MESSAGES];
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // FUNCTION PROTOTYPES
                       ; 
                       ; /*static*/ PRESTO_TCB_T * presto_next_tcb_to_run(void);
                       ; /*static*/ void presto_start_master_timer(void);
                       ; /*static*/ void presto_restart_master_timer(void);
                       ; /*static*/ void idle_task(void);
                       ; /*static*/ BYTE deliver_mail(void);
                       ; /*static*/ PRESTO_TCB_T * tid_to_tcbptr(BYTE tid);
                       ; /*static*/ void print_tcb_list(void);
                       ; /*static*/ void print_mail_list(void);
                       ; /*static*/ void idle_task(void);
                       ; 
                       ; void presto_system_isr_wrapper(void);
                       ; void presto_system_isr(void);
                       ; void context_switch_wrapper(void);
                       ; void context_switch(void);
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   I N I T I A L I Z A T I O N
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void presto_init(void) {
                       ;    BYTE count;
                       ; 
                       ;    // initialize once and only once
                       ;    if(presto_initialized) return;
 0004 7D000D            tst _presto_initialized
 0007 2703              beq L12
 0009 7E00F4            jmp L11
 000C                 L12:
 000C                 kernel.81::	
                       ;    presto_initialized++;
 000C F6000D            ldab _presto_initialized
 000F 4F                clra
 0010 C30001            addd #1
 0013 F7000D            stab _presto_initialized
 0016                 kernel.84::	
                       ; 
                       ;    // initialize master clock
                       ;    presto_master_clock=clock_reset();
 0016 CC0175            ldd #_presto_master_clock
 0019 BD0000            jsr _clock_reset
 001C                 kernel.87::	
                       ; 
                       ;    // initialize TCB list
                       ;    for(count=0;count<MAX_TASKS;count++) {
 001C 6F07              clr 7,x
 001E 2050              bra L17
 0020                 L14:
 0020                 kernel.88::	
                       ;       tcb_list[count].next=&tcb_list[count+1];
 0020 E607              ldab 7,x
 0022 4F                clra
 0023 188F              xgdy
 0025 CC0012            ldd #18
 0028 BD0000            jsr __muli
 002B ED04              std 4,x
 002D C30185            addd #_tcb_list+12
 0030 188F              xgdy
 0032 EC04              ldd 4,x
 0034 C3018B            addd #_tcb_list+18
 0037 18ED00            std 0,y
 003A                 kernel.89::	
                       ;       tcb_list[count].task_id=count;
 003A E607              ldab 7,x
 003C 4F                clra
 003D ED02              std 2,x
 003F CC0012            ldd #18
 0042 1AEE02            ldy 2,x
 0045 BD0000            jsr __muli
 0048 C30179            addd #_tcb_list
 004B 188F              xgdy
 004D E603              ldab 3,x
 004F 18E700            stab 0,y
 0052                 kernel.90::	
                       ;       tcb_list[count].state=STATE_INACTIVE;
 0052 E607              ldab 7,x
 0054 4F                clra
 0055 188F              xgdy
 0057 CC0012            ldd #18
 005A BD0000            jsr __muli
 005D C30183            addd #_tcb_list+10
 0060 188F              xgdy
 0062 CC0002            ldd #2
 0065 18ED00            std 0,y
 0068                 kernel.91::	
                       ;    }
 0068                 L15:
 0068 E607              ldab 7,x
 006A 4F                clra
 006B C30001            addd #1
 006E E707              stab 7,x
 0070                 L17:
 0070 E607              ldab 7,x
 0072 C106              cmpb #6
 0074 25AA              blo L14
 0076                 kernel.92::	
                       ;    tcb_list[MAX_TASKS-1].next=NULL;
 0076 CC0000            ldd #0
 0079 FD01DF            std _tcb_list+90+12
 007C                 kernel.93::	
                       ;    free_tcb_p=&tcb_list[0];
 007C CC0179            ldd #_tcb_list
 007F FD000B            std _free_tcb_p
 0082                 kernel.96::	
                       ; 
                       ;    // initialize mail list
                       ;    for(count=0;count<MAX_MESSAGES;count++) {
 0082 6F07              clr 7,x
 0084 2031              bra L26
 0086                 L23:
 0086                 kernel.97::	
                       ;       mail_list[count].next=&mail_list[count+1];  // goes past end of array - OK
 0086 E607              ldab 7,x
 0088 4F                clra
 0089 05                lsld
 008A 05                lsld
 008B 05                lsld
 008C 05                lsld
 008D ED04              std 4,x
 008F C3000E            addd #_mail_list+14
 0092 188F              xgdy
 0094 EC04              ldd 4,x
 0096 C30010            addd #_mail_list+16
 0099 18ED00            std 0,y
 009C                 kernel.98::	
                       ;       mail_list[count].serial_number=count;
 009C E607              ldab 7,x
 009E 4F                clra
 009F ED02              std 2,x
 00A1 05                lsld
 00A2 05                lsld
 00A3 05                lsld
 00A4 05                lsld
 00A5 C30000            addd #_mail_list
 00A8 188F              xgdy
 00AA EC02              ldd 2,x
 00AC 18ED00            std 0,y
 00AF                 kernel.99::	
                       ;    }
 00AF                 L24:
 00AF E607              ldab 7,x
 00B1 4F                clra
 00B2 C30001            addd #1
 00B5 E707              stab 7,x
 00B7                 L26:
 00B7 E607              ldab 7,x
 00B9 C114              cmpb #20
 00BB 25C9              blo L23
 00BD                 kernel.100::	
                       ;    mail_list[MAX_MESSAGES-1].next=NULL;
 00BD CC0000            ldd #0
 00C0 FD013E            std _mail_list+304+14
 00C3                 kernel.101::	
                       ;    free_mail_p=&mail_list[0];
 00C3 CC0000            ldd #_mail_list
 00C6 FD000E            std _free_mail_p
 00C9                 kernel.105::	
                       ; 
                       ;    // initialize idle task
                       ;    // must be done after presto_initialized++ because of initialization check
                       ;    idle_tid=presto_create_task(idle_task,idle_stack,IDLE_STACK_SIZE,IDLE_PRIORITY);
 00C9 CC0000            ldd #0
 00CC 37                pshb
 00CD 36                psha
 00CE CC0032            ldd #50
 00D1 37                pshb
 00D2 36                psha
 00D3 CC0143            ldd #_idle_stack
 00D6 37                pshb
 00D7 36                psha
 00D8 CC0861            ldd #_idle_task
 00DB BD0154            jsr _presto_create_task
 00DE BD0000            jsr __movspb
 00E1 06                .byte 6
 00E2 4F                clra
 00E3 5D                tstb
 00E4 2A01              bpl X0
 00E6 43                coma
 00E7                 X0:
 00E7 F70140            stab _idle_tid
 00EA                 kernel.106::	
                       ;    idle_tcb_p=tid_to_tcbptr(idle_tid);
 00EA F60140            ldab _idle_tid
 00ED 4F                clra
 00EE BD0864            jsr _tid_to_tcbptr
 00F1 FD0141            std _idle_tcb_p
 00F4                 kernel.107::	
                       ; }
 00F4                 L11:
 00F4 8F                xgdx
 00F5 C30008            addd #8
 00F8 8F                xgdx
 00F9 35                txs
 00FA 38                pulx
 00FB 39                rts
                       ;  IX -> 0,x
 00FC                 _presto_start_scheduler::
 00FC                 kernel.113::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void presto_start_scheduler(void) {
                       ; 
                       ;    if(presto_initialized==0) presto_fatal_error();
 00FC 7D000D            tst _presto_initialized
 00FF 2603              bne L32
 0101 BD0000            jsr _presto_fatal_error
 0104                 L32:
 0104 0F                    sei
 0105                 kernel.119::	
                       ; 
                       ;    // we're about to switch to our first task... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    //set_interrupt(INTR_TOC2, presto_system_isr_wrapper);
                       ;    set_interrupt(INTR_TOC2, presto_system_isr);
 0105 CC030D            ldd #_presto_system_isr
 0108 37                pshb
 0109 36                psha
 010A CC0008            ldd #8
 010D BD0000            jsr _set_interrupt
 0110 1838              puly
 0112                 kernel.120::	
                       ;    set_interrupt(INTR_SWI, context_switch);
 0112 CC03AE            ldd #_context_switch
 0115 37                pshb
 0116 36                psha
 0117 CC0010            ldd #16
 011A BD0000            jsr _set_interrupt
 011D 1838              puly
 011F                 kernel.123::	
                       ; 
                       ;    // start timer interrupts for pre-emption
                       ;    presto_start_master_timer();
 011F BD08BF            jsr _presto_start_master_timer
 0122                 kernel.127::	
                       ; 
                       ;    // pick next task to run
                       ;    // first task in list is highest priority and is ready
                       ;    current_tcb_p=tcb_head_p;
 0122 FC0009            ldd _tcb_head_p
 0125 FD0006            std _current_tcb_p
 0128                 kernel.128::	
                       ;    if(current_tcb_p==NULL) {
 0128 FC0006            ldd _current_tcb_p
 012B 2603              bne L34
 012D                 kernel.129::	
                       ;       presto_fatal_error();
 012D BD0000            jsr _presto_fatal_error
 0130                 kernel.130::	
                       ;    }
 0130                 L34:
 0130                 kernel.131::	
                       ;    current_tid=current_tcb_p->task_id;
 0130 18FE0006          ldy _current_tcb_p
 0134 18E600            ldab 0,y
 0137 F70008            stab _current_tid
 013A                 kernel.137::	
                       ; 
                       ;    // SET UP A NEW STACK AND START EXECUTION USING IT
                       ; 
                       ;    // these parameters will be used in inline assembly...
                       ;    // must be put in global space, not on stack
                       ;    global_new_sp=current_tcb_p->stack_ptr;
 013A FC0006            ldd _current_tcb_p
 013D C30002            addd #2
 0140 188F              xgdy
 0142 18EC00            ldd 0,y
 0145 FD0000            std _global_new_sp
 0148 BE0000            lds _global_new_sp
 014B 32                pula
 014C 84EF              anda ~#0x10
 014E 36                psha
 014F 3B                rti
 0150                 kernel.153::	
                       ; 
                       ;    asm("lds _global_new_sp");
                       ; 
                       ;    // Clear interrupt mask bit (to enable ints) in the CC register on the stack.
                       ;    // That way, the new task will have interrupts enabled when it wakes up.
                       ;    asm("pula");
                       ;    ENABLE_CCR_INTERRUPT_BIT;
                       ;    asm("psha");
                       ; 
                       ;    // Normally, this function would end with an RTS, but we want to act EXACTLY
                       ;    // the same as if we had just been inside of an interrupt.  So we manually
                       ;    // call RTI here to pop the registers and "run" the new task.
                       ;    asm("rti");
                       ; 
                       ;    // we never get here
                       ;    presto_fatal_error();
 0150 BD0000            jsr _presto_fatal_error
 0153                 kernel.154::	
                       ; }
 0153                 L31:
 0153 39                rts
                       ;  IX -> 0,x
                       ;            ptr -> 2,x
                       ;      new_tcb_p -> 4,x
                       ;       priority -> 17,x
                       ;     stack_size -> 14,x
                       ;          stack -> 12,x
                       ;           func -> 8,x
 0154                 _presto_create_task::
 0154 BD0000            jsr __enterb
 0157 46                .byte 0x46
 0158 EC10              ldd 16,x
 015A E711              stab 17,x
 015C                 kernel.164::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   T A S K   M A N A G E M E N T
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; PRESTO_TID_T presto_create_task( void (*func)(void), BYTE * stack, short stack_size, BYTE priority ) {
                       ; 
                       ;    PRESTO_TCB_T * new_tcb_p;
                       ; 
                       ;    if(presto_initialized==0) presto_fatal_error();
 015C 7D000D            tst _presto_initialized
 015F 2603              bne L37
 0161 BD0000            jsr _presto_fatal_error
 0164                 L37:
 0164                 kernel.166::	
                       ; 
                       ;    if(free_tcb_p==NULL) {
 0164 FC000B            ldd _free_tcb_p
 0167 2610              bne L39
 0169                 kernel.168::	
                       ;       // There are no more TCB's left.
                       ;       presto_fatal_error();
 0169 BD0000            jsr _presto_fatal_error
 016C                 kernel.169::	
                       ;       return -1;
 016C CCFFFF            ldd #-1
 016F 8F                xgdx
 0170 C30006            addd #6
 0173 8F                xgdx
 0174 35                txs
 0175 38                pulx
 0176 1838              puly
 0178 39                rts
 0179                 L39:
 0179 0F                    sei
 017A                 kernel.176::	
                       ;    }
                       ; 
                       ;    // we're about to mess with tasks, TCB's... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    // allocate TCB for new task
                       ;    new_tcb_p=free_tcb_p;
 017A FC000B            ldd _free_tcb_p
 017D ED04              std 4,x
 017F                 kernel.177::	
                       ;    free_tcb_p=free_tcb_p->next;
 017F FC000B            ldd _free_tcb_p
 0182 C3000C            addd #12
 0185 188F              xgdy
 0187 18EC00            ldd 0,y
 018A FD000B            std _free_tcb_p
 018D                 kernel.181::	
                       ; 
                       ;    // initialize TCB elements
                       ;    // new_tcb_p->task_id is already assigned
                       ;    new_tcb_p->stack_top=stack+stack_size-1;
 018D EC04              ldd 4,x
 018F C30004            addd #4
 0192 188F              xgdy
 0194 EC0E              ldd 14,x
 0196 E30C              addd 12,x
 0198 C3FFFF            addd #-1
 019B 18ED00            std 0,y
 019E                 kernel.182::	
                       ;    new_tcb_p->stack_bottom=stack;
 019E EC04              ldd 4,x
 01A0 C30006            addd #6
 01A3 188F              xgdy
 01A5 EC0C              ldd 12,x
 01A7 18ED00            std 0,y
 01AA                 kernel.183::	
                       ;    new_tcb_p->stack_ptr=new_tcb_p->stack_top;
 01AA EC04              ldd 4,x
 01AC C30004            addd #4
 01AF 188F              xgdy
 01B1 18EC00            ldd 0,y
 01B4 37                pshb ; 
 01B5 36                psha ; spill
 01B6 EC04              ldd 4,x
 01B8 C30002            addd #2
 01BB 188F              xgdy
 01BD 32                pula ; 
 01BE 33                pulb ; reload
 01BF 18ED00            std 0,y
 01C2                 kernel.184::	
                       ;    new_tcb_p->priority=priority;
 01C2 EC04              ldd 4,x
 01C4 C30008            addd #8
 01C7 188F              xgdy
 01C9 E611              ldab 17,x
 01CB 18E700            stab 0,y
 01CE                 kernel.185::	
                       ;    new_tcb_p->state=STATE_READY;
 01CE EC04              ldd 4,x
 01D0 C3000A            addd #10
 01D3 188F              xgdy
 01D5 CC0000            ldd #0
 01D8 18ED00            std 0,y
 01DB                 kernel.186::	
                       ;    new_tcb_p->mailbox_head=NULL;
 01DB EC04              ldd 4,x
 01DD C3000E            addd #14
 01E0 188F              xgdy
 01E2 CC0000            ldd #0
 01E5 18ED00            std 0,y
 01E8                 kernel.187::	
                       ;    new_tcb_p->mailbox_tail=NULL;
 01E8 EC04              ldd 4,x
 01EA C30010            addd #16
 01ED 188F              xgdy
 01EF CC0000            ldd #0
 01F2 18ED00            std 0,y
 01F5                 kernel.193::	
                       ; 
                       ;    // SET UP NEW STACK USING ASSEMBLY LANGUAGE
                       ; 
                       ;    // these parameters will be used in inline assembly...
                       ;    // must be put in global space, not on stack
                       ;    global_new_sp=new_tcb_p->stack_ptr;
 01F5 EC04              ldd 4,x
 01F7 C30002            addd #2
 01FA 188F              xgdy
 01FC 18EC00            ldd 0,y
 01FF FD0000            std _global_new_sp
 0202                 kernel.194::	
                       ;    global_new_fn=func;
 0202 EC08              ldd 8,x
 0204 FD0004            std _global_new_fn
 0207 BF01E5            sts _global_save_sp
 020A BE0000            lds _global_new_sp
 020D FC0004            ldd _global_new_fn
 0210 37                pshb
 0211 36                psha
 0212 8600              ldaa #0
 0214 36                psha
 0215 36                psha
 0216 36                psha
 0217 36                psha
 0218 36                psha
 0219 36                psha
 021A 07                tpa
 021B 84EF              anda ~#0x10
 021D 36                psha
 021E BF0000            sts _global_new_sp
 0221 BE01E5            lds _global_save_sp
 0224                 kernel.235::	
                       ; 
                       ;    // store our own SP so we can work on the new task
                       ;    asm("sts _global_save_sp");
                       ; 
                       ;    // load empty SP from task so we can initialize it
                       ;    asm("lds _global_new_sp");
                       ; 
                       ; /*
                       ;    // Set presto_fatal_error as the "return pc" of a new task.  If some bozo
                       ;    // tries to return out of his task's main function, we will cause an alarm.
                       ;    asm("ldd #_presto_fatal_error");
                       ;    asm("pshb");
                       ;    asm("psha");
                       ; */
                       ; 
                       ;    // push the actual function call on the stack
                       ;    asm("ldd _global_new_fn");
                       ;    asm("pshb");
                       ;    asm("psha");
                       ; 
                       ;    // push any old stinkin' registers onto the stack
                       ;    // they'll be pulled off when we start running
                       ;    // we push in interrupt-stack order
                       ;    asm("ldaa #0");
                       ;    asm("psha"); // Y(L) register
                       ;    asm("psha"); // Y(H) register
                       ;    asm("psha"); // X(L) register
                       ;    asm("psha"); // X(H) register
                       ;    asm("psha"); // A register
                       ;    asm("psha"); // B register
                       ;    asm("tpa");  // do not push $00 here, use actual condition codes
                       ;    ENABLE_CCR_INTERRUPT_BIT;  // enable interrupts in pushed CC register (I bit cleared)
                       ;    asm("psha");  // 1 byte, the condition codes
                       ; 
                       ;    // save task SP in TCB
                       ;    asm("sts _global_new_sp");
                       ;    // re-load our own SP so we can return
                       ;    asm("lds _global_save_sp");
                       ; 
                       ;    // recover the altered stack pointer and save it in the TCB
                       ;    new_tcb_p->stack_ptr=global_new_sp;
 0224 EC04              ldd 4,x
 0226 C30002            addd #2
 0229 188F              xgdy
 022B FC0000            ldd _global_new_sp
 022E 18ED00            std 0,y
 0231                 kernel.239::	
                       ; 
                       ;    // INSERT NEW TCB INTO LIST IN PRIORITY ORDER
                       ; 
                       ;    if(tcb_head_p==NULL) {
 0231 FC0009            ldd _tcb_head_p
 0234 2615              bne L41
 0236                 kernel.241::	
                       ;       // we are the first TCB in the list
                       ;       tcb_head_p=new_tcb_p;
 0236 EC04              ldd 4,x
 0238 FD0009            std _tcb_head_p
 023B                 kernel.242::	
                       ;       new_tcb_p->next=NULL;
 023B EC04              ldd 4,x
 023D C3000C            addd #12
 0240 188F              xgdy
 0242 CC0000            ldd #0
 0245 18ED00            std 0,y
 0248                 kernel.243::	
                       ;    } else if((new_tcb_p->priority)>(tcb_head_p->priority)) {
 0248 7E02E2            jmp L42
 024B                 L41:
 024B EC04              ldd 4,x
 024D C30008            addd #8
 0250 188F              xgdy
 0252 18E600            ldab 0,y
 0255 37                pshb ; 
 0256 36                psha ; spill
 0257 FC0009            ldd _tcb_head_p
 025A C30008            addd #8
 025D 188F              xgdy
 025F 32                pula ; 
 0260 33                pulb ; reload
 0261 18E100            cmpb 0,y
 0264 2315              bls L43
 0266                 kernel.245::	
                       ;       // advance to the head of the class!
                       ;       new_tcb_p->next=tcb_head_p;
 0266 EC04              ldd 4,x
 0268 C3000C            addd #12
 026B 188F              xgdy
 026D FC0009            ldd _tcb_head_p
 0270 18ED00            std 0,y
 0273                 kernel.246::	
                       ;       tcb_head_p=new_tcb_p;
 0273 EC04              ldd 4,x
 0275 FD0009            std _tcb_head_p
 0278                 kernel.247::	
                       ;    } else {
 0278 7E02E2            jmp L44
 027B                 L43:
 027B                 kernel.248::	
                       ;       PRESTO_TCB_T * ptr=tcb_head_p;
 027B FC0009            ldd _tcb_head_p
 027E ED02              std 2,x
 0280 2030              bra L46
 0282                 L45:
 0282                 kernel.250::	
                       ;       while(ptr->next!=NULL) {
                       ;          if((new_tcb_p->priority)>(ptr->next->priority)) break;
 0282 EC02              ldd 2,x
 0284 C3000C            addd #12
 0287 188F              xgdy
 0289 18EC00            ldd 0,y
 028C C30008            addd #8
 028F 188F              xgdy
 0291 EC04              ldd 4,x
 0293 C30008            addd #8
 0296 183C              pshy ; spill
 0298 188F              xgdy
 029A 18E600            ldab 0,y
 029D 1838              puly ; reload
 029F 18E100            cmpb 0,y
 02A2 2302              bls L48
 02A4 2018              bra L47
 02A6                 L48:
 02A6                 kernel.251::	
                       ;          ptr=ptr->next;
 02A6 EC02              ldd 2,x
 02A8 C3000C            addd #12
 02AB 188F              xgdy
 02AD 18EC00            ldd 0,y
 02B0 ED02              std 2,x
 02B2                 kernel.252::	
                       ;       }
 02B2                 L46:
 02B2 EC02              ldd 2,x
 02B4 C3000C            addd #12
 02B7 188F              xgdy
 02B9 18EC00            ldd 0,y
 02BC 26C4              bne L45
 02BE                 L47:
 02BE                 kernel.256::	
                       ; 
                       ;       // ptr->next is either NULL or lower priority than us
                       ;       // either way, we want to get inserted between ptr and ptr->next
                       ;       new_tcb_p->next=ptr->next;
 02BE EC02              ldd 2,x
 02C0 C3000C            addd #12
 02C3 188F              xgdy
 02C5 18EC00            ldd 0,y
 02C8 37                pshb ; 
 02C9 36                psha ; spill
 02CA EC04              ldd 4,x
 02CC C3000C            addd #12
 02CF 188F              xgdy
 02D1 32                pula ; 
 02D2 33                pulb ; reload
 02D3 18ED00            std 0,y
 02D6                 kernel.257::	
                       ;       ptr->next=new_tcb_p;
 02D6 EC02              ldd 2,x
 02D8 C3000C            addd #12
 02DB 188F              xgdy
 02DD EC04              ldd 4,x
 02DF 18ED00            std 0,y
 02E2                 kernel.258::	
                       ;    }
 02E2                 L44:
 02E2                 L42:
 02E2 0E                    cli
 02E3                 kernel.263::	
                       ; 
                       ;    // we're done messing with the task list... interrupts back on
                       ;    INTR_ON();
                       ; 
                       ;    return new_tcb_p->task_id;
 02E3 1AEE04            ldy 4,x
 02E6 18E600            ldab 0,y
 02E9 4F                clra
 02EA 5D                tstb
 02EB 2A01              bpl X1
 02ED 43                coma
 02EE                 X1:
 02EE 8F                xgdx
 02EF C30006            addd #6
 02F2 8F                xgdx
 02F3 35                txs
 02F4 38                pulx
 02F5 1838              puly
 02F7 39                rts
 02F8                 L36:
 02F8 8F                xgdx
 02F9 C30006            addd #6
 02FC 8F                xgdx
 02FD 35                txs
 02FE 38                pulx
 02FF 1838              puly
 0301 39                rts
                       ;  IX -> 0,x
 0302                 _presto_kill_self::
 0302                 kernel.270::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void presto_kill_self(void) {
                       ;    // TODO - remove TCB from list
                       ;    presto_fatal_error();
 0302 BD0000            jsr _presto_fatal_error
 0305                 kernel.271::	
                       ; }
 0305                 L50:
 0305 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
 0306                 _presto_system_isr_wrapper::
 0306 BD0000            jsr __enterb
 0309 08                .byte 0x8
 030A                 kernel.287::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   C O N T E X T   S W I T C H I N G   ( I N T E R R U P T )
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #pragma interrupt presto_system_isr_wrapper
                       ; void presto_system_isr_wrapper(void) {
                       ; 
                       ;    // The ICC compiler adds a "jsr __enterb" at the beginning of my interrupt
                       ;    // service routine.  Apparently, it is concerned with preserving the state
                       ;    // of the X register, and it tries to push it onto the stack and then do some
                       ;    // funny math.  At the end of the ISR, it tries to undo all of the mess, and
                       ;    // it even ends the ISR with a jump instruction.  Yikes!  I use this label
                       ;    // to by-pass this destructive behavior at the top, and later I use an
                       ;    // inline "RTI" instruction to by-pass the stuff at the bottom.
                       ;    presto_fatal_error();
 030A BD0000            jsr _presto_fatal_error
 030D                 	_presto_system_isr::
 030D                 kernel.296::	
                       ; 
                       ;    asm("_presto_system_isr::");
                       ; 
                       ;    // registers are pushed when timer interrupt is executed
                       ; 
                       ;    // interrupts are disabled at this time
                       ; 
                       ;    // take care of clock things
                       ;    presto_master_clock=clock_add(presto_master_clock,MS_PER_TICK);
 030D CC0064            ldd #100
 0310 37                pshb
 0311 36                psha
 0312 EC00              ldd 0,x
 0314 C30004            addd #4
 0317 18CE0175          ldy #_presto_master_clock
 031B 3C                pshx
 031C 8F                xgdx
 031D CC0004            ldd #4
 0320 BD0000            jsr __asgnblk
 0323 38                pulx
 0324 EC00              ldd 0,x
 0326 C30004            addd #4
 0329 37                pshb
 032A 36                psha
 032B CC0175            ldd #_presto_master_clock
 032E BD0000            jsr _clock_add
 0331 1838              puly
 0333 1838              puly
 0335                 kernel.297::	
                       ;    presto_restart_master_timer();
 0335 BD08F4            jsr _presto_restart_master_timer
 0338                 kernel.300::	
                       ; 
                       ;    // check mail
                       ;    if(deliver_mail()>0) {
 0338 BD076B            jsr _deliver_mail
 033B C100              cmpb #0
 033D 235F              bls L52
 033F                 kernel.303::	
                       ; 
                       ;       // check to see if we've clobbered our stack
                       ;       if(((current_tcb_p->stack_ptr)>(current_tcb_p->stack_top))
 033F FC0006            ldd _current_tcb_p
 0342 C30002            addd #2
 0345 188F              xgdy
 0347 18EC00            ldd 0,y
 034A ED02              std 2,x
 034C FC0006            ldd _current_tcb_p
 034F C30004            addd #4
 0352 188F              xgdy
 0354 EC02              ldd 2,x
 0356 CDA300            cpd 0,y
 0359 220F              bhi L56
 035B FC0006            ldd _current_tcb_p
 035E C30006            addd #6
 0361 188F              xgdy
 0363 EC02              ldd 2,x
 0365 CDA300            cpd 0,y
 0368 2403              bhs L54
 036A                 L56:
 036A                 kernel.305::	
                       ;       ||((current_tcb_p->stack_ptr)<(current_tcb_p->stack_bottom)))
                       ;          presto_fatal_error();
 036A BD0000            jsr _presto_fatal_error
 036D                 L54:
 036D                 kernel.311::	
                       ; 
                       ;       // these parameters will be used in inline assembly...
                       ;       // must be put in global space, not on stack
                       ; 
                       ;       // the ISR will save old SP in old TCB
                       ;       global_old_sp_p=&(current_tcb_p->stack_ptr);
 036D FC0006            ldd _current_tcb_p
 0370 C30002            addd #2
 0373 FD0002            std _global_old_sp_p
 0376                 kernel.314::	
                       ; 
                       ;       // pick next task to run
                       ;       current_tcb_p=presto_next_tcb_to_run();
 0376 BD0447            jsr _presto_next_tcb_to_run
 0379 FD0006            std _current_tcb_p
 037C                 kernel.315::	
                       ;       current_tid=current_tcb_p->task_id;
 037C 18FE0006          ldy _current_tcb_p
 0380 18E600            ldab 0,y
 0383 F70008            stab _current_tid
 0386                 kernel.318::	
                       ; 
                       ;       // end of ISR will set up new stack
                       ;       global_new_sp=current_tcb_p->stack_ptr;
 0386 FC0006            ldd _current_tcb_p
 0389 C30002            addd #2
 038C 188F              xgdy
 038E 18EC00            ldd 0,y
 0391 FD0000            std _global_new_sp
 0394 18FE0002          ldy _global_old_sp_p
 0398 18AF00            sts 0,y
 039B BE0000            lds _global_new_sp
 039E                 kernel.325::	
                       ; 
                       ;       // store the old stack pointer
                       ;       asm("ldy _global_old_sp_p");
                       ;       asm("sts 0,y");
                       ;       // load the new stack pointer
                       ;       asm("lds _global_new_sp");
                       ;    }
 039E                 L52:
 039E 3B                rti
 039F                 kernel.345::	
                       ; 
                       ; /*
                       ;    // Clear interrupt mask bit (to enable ints) in the CC register on the stack.
                       ;    // That way, the new task will have interrupts enabled when it wakes up.
                       ;    asm("pula");
                       ;    ENABLE_CCR_INTERRUPT_BIT;
                       ;    asm("psha");
                       ; */
                       ; 
                       ;    // The end of this function SHOULD be an RTI (instead of RTS), because it is
                       ;    // an interrupt.  But the ICC compiler adds a lot of stuff at the beginning
                       ;    // and the end of interrupt service routines.  Specifically, it is messing
                       ;    // with the X register (pushing it onto the stack) because it uses that as
                       ;    // a frame pointer.  So I will add my RTI here explicitly, to force the
                       ;    // behavior that I want.
                       ;    // Now we will pop the stack and "run" the new task.
                       ;    asm("rti");
                       ; 
                       ;    // we never get here
                       ;    presto_fatal_error();
 039F BD0000            jsr _presto_fatal_error
 03A2                 kernel.346::	
                       ; }
 03A2                 L51:
 03A2 8F                xgdx
 03A3 C30008            addd #8
 03A6 8F                xgdx
 03A7 35                txs
 03A8 38                pulx
 03A9 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
 03AA                 _context_switch_wrapper::
 03AA BD0000            jsr __enterb
 03AD 06                .byte 0x6
 03AE                 	_context_switch::
 03AE                 kernel.357::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void context_switch_wrapper(void) {
                       ; 
                       ;    asm("_context_switch::");
                       ; 
                       ;    // registers are pushed when SWI is executed
                       ; 
                       ;    // check to see if the old task has clobbered its stack
                       ;    if(((current_tcb_p->stack_ptr)>(current_tcb_p->stack_top))
 03AE FC0006            ldd _current_tcb_p
 03B1 C30002            addd #2
 03B4 188F              xgdy
 03B6 18EC00            ldd 0,y
 03B9 ED04              std 4,x
 03BB FC0006            ldd _current_tcb_p
 03BE C30004            addd #4
 03C1 188F              xgdy
 03C3 EC04              ldd 4,x
 03C5 CDA300            cpd 0,y
 03C8 220F              bhi L60
 03CA FC0006            ldd _current_tcb_p
 03CD C30006            addd #6
 03D0 188F              xgdy
 03D2 EC04              ldd 4,x
 03D4 CDA300            cpd 0,y
 03D7 2403              bhs L58
 03D9                 L60:
 03D9                 kernel.359::	
                       ;    ||((current_tcb_p->stack_ptr)<(current_tcb_p->stack_bottom)))
                       ;       presto_fatal_error();
 03D9 BD0000            jsr _presto_fatal_error
 03DC                 L58:
 03DC                 kernel.362::	
                       ; 
                       ;    // the inline asm will save old SP in old TCB
                       ;    global_old_sp_p=&(current_tcb_p->stack_ptr);
 03DC FC0006            ldd _current_tcb_p
 03DF C30002            addd #2
 03E2 FD0002            std _global_old_sp_p
 03E5                 kernel.365::	
                       ; 
                       ;    // pick next task to run
                       ;    current_tcb_p=presto_next_tcb_to_run();
 03E5 BD0447            jsr _presto_next_tcb_to_run
 03E8 FD0006            std _current_tcb_p
 03EB                 kernel.366::	
                       ;    current_tid=current_tcb_p->task_id;
 03EB 18FE0006          ldy _current_tcb_p
 03EF 18E600            ldab 0,y
 03F2 F70008            stab _current_tid
 03F5                 kernel.369::	
                       ; 
                       ;    // check to see if the new task has clobbered its stack
                       ;    if(((current_tcb_p->stack_ptr)>(current_tcb_p->stack_top))
 03F5 FC0006            ldd _current_tcb_p
 03F8 C30002            addd #2
 03FB 188F              xgdy
 03FD 18EC00            ldd 0,y
 0400 ED02              std 2,x
 0402 FC0006            ldd _current_tcb_p
 0405 C30004            addd #4
 0408 188F              xgdy
 040A EC02              ldd 2,x
 040C CDA300            cpd 0,y
 040F 220F              bhi L63
 0411 FC0006            ldd _current_tcb_p
 0414 C30006            addd #6
 0417 188F              xgdy
 0419 EC02              ldd 2,x
 041B CDA300            cpd 0,y
 041E 2403              bhs L61
 0420                 L63:
 0420                 kernel.371::	
                       ;    ||((current_tcb_p->stack_ptr)<(current_tcb_p->stack_bottom)))
                       ;       presto_fatal_error();
 0420 BD0000            jsr _presto_fatal_error
 0423                 L61:
 0423                 kernel.376::	
                       ; 
                       ;    // call asm routine to set up new stack
                       ;    // when we return, we'll be another process
                       ;    // the asm routine will re-enable interrupts
                       ;    global_new_sp=current_tcb_p->stack_ptr;
 0423 FC0006            ldd _current_tcb_p
 0426 C30002            addd #2
 0429 188F              xgdy
 042B 18EC00            ldd 0,y
 042E FD0000            std _global_new_sp
 0431 18FE0002          ldy _global_old_sp_p
 0435 18AF00            sts 0,y
 0438 BE0000            lds _global_new_sp
 043B 3B                rti
 043C                 kernel.410::	
                       ; 
                       ; /*
                       ;    // AIGH! - REGISTERS PUSHED A SECOND TIME HERE!!
                       ;    // save the registers (in the same order that an interrupt does)
                       ;    asm("pshy");  // 2 bytes (Low, then High)
                       ;    asm("pshx");  // 2 bytes (Low, then High)
                       ;    asm("psha");  // 1 byte
                       ;    asm("pshb");  // 1 byte
                       ;    asm("tpa");
                       ;    ENABLE_CCR_INTERRUPT_BIT;  // enable interrupts in pushed CC register
                       ;    asm("psha");  // 1 byte, the condition codes
                       ; */
                       ; 
                       ;    // store the old stack pointer
                       ;    asm("ldy _global_old_sp_p");
                       ;    asm("sts 0,y");
                       ;    // load the new stack pointer
                       ;    asm("lds _global_new_sp");
                       ; 
                       ; /*
                       ;    // Clear interrupt mask bit (to enable ints) in the CC register on the stack.
                       ;    // That way, the new task will have interrupts enabled when it wakes up.
                       ;    asm("pula");
                       ;    ENABLE_CCR_INTERRUPT_BIT;
                       ;    asm("psha");
                       ; */
                       ; 
                       ;    // Normally, this function would end with an RTS, but we want to act EXACTLY
                       ;    // the same as if we had just been inside of an interrupt.  So we manually
                       ;    // call RTI here to pop the registers and "run" the new task.
                       ;    asm("rti");
                       ; 
                       ;    // we never get here
                       ;    presto_fatal_error();
 043C BD0000            jsr _presto_fatal_error
 043F                 kernel.411::	
                       ; }
 043F                 L57:
 043F 8F                xgdx
 0440 C30006            addd #6
 0443 8F                xgdx
 0444 35                txs
 0445 38                pulx
 0446 39                rts
                       ;  IX -> 0,x
                       ;            ptr -> 2,x
 0447                 _presto_next_tcb_to_run::
 0447 BD0000            jsr __enterb
 044A 04                .byte 0x4
 044B                 kernel.420::	
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   S C H E D U L I N G
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ PRESTO_TCB_T * presto_next_tcb_to_run(void) {
                       ;    // pick highest priority ready task to run
                       ;    PRESTO_TCB_T * ptr=tcb_head_p;
 044B FC0009            ldd _tcb_head_p
 044E ED02              std 2,x
 0450 2022              bra L66
 0452                 L65:
 0452                 kernel.422::	
                       ;    while(ptr!=NULL) {
                       ;       if(ptr->state==STATE_READY) return ptr;
 0452 EC02              ldd 2,x
 0454 C3000A            addd #10
 0457 188F              xgdy
 0459 18EC00            ldd 0,y
 045C 260A              bne L68
 045E EC02              ldd 2,x
 0460 8F                xgdx
 0461 C30004            addd #4
 0464 8F                xgdx
 0465 35                txs
 0466 38                pulx
 0467 39                rts
 0468                 L68:
 0468                 kernel.423::	
                       ;       ptr=ptr->next;
 0468 EC02              ldd 2,x
 046A C3000C            addd #12
 046D 188F              xgdy
 046F 18EC00            ldd 0,y
 0472 ED02              std 2,x
 0474                 kernel.424::	
                       ;    }
 0474                 L66:
 0474 EC02              ldd 2,x
 0476 26DA              bne L65
 0478                 kernel.426::	
                       ;    // should never get here
                       ;    presto_fatal_error();
 0478 BD0000            jsr _presto_fatal_error
 047B                 kernel.427::	
                       ;    return NULL;
 047B CC0000            ldd #0
 047E 8F                xgdx
 047F C30004            addd #4
 0482 8F                xgdx
 0483 35                txs
 0484 38                pulx
 0485 39                rts
 0486                 L64:
 0486 8F                xgdx
 0487 C30004            addd #4
 048A 8F                xgdx
 048B 35                txs
 048C 38                pulx
 048D 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;        payload -> 12,x
                       ;             to -> 9,x
 048E                 _presto_send_message::
 048E BD0000            jsr __enterb
 0491 46                .byte 0x46
 0492                 kernel.435::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   M E S S A G E S   A N D   T I M E R S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; BYTE presto_send_message(PRESTO_TID_T to, PRESTO_MAIL_T payload) {
                       ;    return presto_timer(to,0,payload);
 0492 EC00              ldd 0,x
 0494 C30002            addd #2
 0497 1AEE0C            ldy 12,x
 049A 3C                pshx
 049B 8F                xgdx
 049C CC0004            ldd #4
 049F BD0000            jsr __asgnblk
 04A2 38                pulx
 04A3 EC00              ldd 0,x
 04A5 C30002            addd #2
 04A8 37                pshb
 04A9 36                psha
 04AA CC0000            ldd #0
 04AD 37                pshb
 04AE 36                psha
 04AF E609              ldab 9,x
 04B1 4F                clra
 04B2 5D                tstb
 04B3 2A01              bpl X2
 04B5 43                coma
 04B6                 X2:
 04B6 BD04D2            jsr _presto_timer
 04B9 1838              puly
 04BB 1838              puly
 04BD 4F                clra
 04BE 8F                xgdx
 04BF C30006            addd #6
 04C2 8F                xgdx
 04C3 35                txs
 04C4 38                pulx
 04C5 1838              puly
 04C7 39                rts
 04C8                 L70:
 04C8 8F                xgdx
 04C9 C30006            addd #6
 04CC 8F                xgdx
 04CD 35                txs
 04CE 38                pulx
 04CF 1838              puly
 04D1 39                rts
                       ;  IX -> 0,x
                       ;  func temp: 2,x - 6,x
                       ;          ?temp -> 6,x
                       ;          ?temp -> 10,x
                       ;          msg_p -> 14,x
                       ;          ?temp -> 16,x
                       ;          ?temp -> 20,x
                       ;          ?temp -> 24,x
                       ;          ?temp -> 28,x
                       ;        tcb_ptr -> 32,x
                       ;     new_mail_p -> 34,x
                       ;        payload -> 44,x
                       ;          delay -> 42,x
                       ;             to -> 39,x
 04D2                 _presto_timer::
 04D2 BD0000            jsr __enterb
 04D5 64                .byte 0x64
 04D6 0F                    sei
 04D7                 kernel.448::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; BYTE presto_timer(PRESTO_TID_T to, unsigned short delay, PRESTO_MAIL_T payload) {
                       ;    PRESTO_MESSAGE_T * new_mail_p;
                       ;    PRESTO_TCB_T * tcb_ptr;
                       ; 
                       ;    // we're going to mess with the PO mail list... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    // check to see if there's room
                       ;    if(free_mail_p==NULL) {
 04D7 FC000E            ldd _free_mail_p
 04DA 2603              bne L72
 04DC                 kernel.449::	
                       ;       presto_fatal_error();
 04DC BD0000            jsr _presto_fatal_error
 04DF                 kernel.450::	
                       ;    }
 04DF                 L72:
 04DF                 kernel.453::	
                       ; 
                       ;    // check to see that the recipient is an alive task
                       ;    tcb_ptr=tid_to_tcbptr(to);
 04DF E627              ldab 39,x
 04E1 4F                clra
 04E2 5D                tstb
 04E3 2A01              bpl X3
 04E5 43                coma
 04E6                 X3:
 04E6 4F                clra
 04E7 BD0864            jsr _tid_to_tcbptr
 04EA ED20              std 32,x
 04EC                 kernel.454::	
                       ;    if(tcb_ptr==NULL) {
 04EC EC20              ldd 32,x
 04EE 2603              bne L74
 04F0                 kernel.455::	
                       ;       presto_fatal_error();
 04F0 BD0000            jsr _presto_fatal_error
 04F3                 kernel.456::	
                       ;    }
 04F3                 L74:
 04F3                 kernel.459::	
                       ; 
                       ;    // allocate space for a new message
                       ;    new_mail_p=free_mail_p;
 04F3 FC000E            ldd _free_mail_p
 04F6 ED22              std 34,x
 04F8                 kernel.460::	
                       ;    free_mail_p=free_mail_p->next;
 04F8 FC000E            ldd _free_mail_p
 04FB C3000E            addd #14
 04FE 188F              xgdy
 0500 18EC00            ldd 0,y
 0503 FD000E            std _free_mail_p
 0506                 kernel.464::	
                       ; 
                       ;    // fill in the blanks
                       ;    // new_mail_p->serial_number;   already set
                       ;    new_mail_p->from_tid=current_tcb_p->task_id;
 0506 EC22              ldd 34,x
 0508 C30002            addd #2
 050B 188F              xgdy
 050D 183C              pshy ; spill
 050F 18FE0006          ldy _current_tcb_p
 0513 18E600            ldab 0,y
 0516 1838              puly ; reload
 0518 18E700            stab 0,y
 051B                 kernel.465::	
                       ;    new_mail_p->to_tcb_p=tcb_ptr;
 051B EC22              ldd 34,x
 051D C30004            addd #4
 0520 188F              xgdy
 0522 EC20              ldd 32,x
 0524 18ED00            std 0,y
 0527                 kernel.466::	
                       ;    new_mail_p->delivery_time=clock_add(presto_master_clock,delay);
 0527 EC2A              ldd 42,x
 0529 37                pshb
 052A 36                psha
 052B EC00              ldd 0,x
 052D C3001C            addd #28
 0530 18CE0175          ldy #_presto_master_clock
 0534 3C                pshx
 0535 8F                xgdx
 0536 CC0004            ldd #4
 0539 BD0000            jsr __asgnblk
 053C 38                pulx
 053D EC00              ldd 0,x
 053F C3001C            addd #28
 0542 37                pshb
 0543 36                psha
 0544 EC00              ldd 0,x
 0546 C30018            addd #24
 0549 BD0000            jsr _clock_add
 054C 1838              puly
 054E 1838              puly
 0550 EC00              ldd 0,x
 0552 C30018            addd #24
 0555 188F              xgdy
 0557 EC22              ldd 34,x
 0559 C30006            addd #6
 055C 3C                pshx
 055D 8F                xgdx
 055E CC0004            ldd #4
 0561 BD0000            jsr __asgnblk
 0564 38                pulx
 0565                 kernel.467::	
                       ;    new_mail_p->payload=payload;
 0565 EC22              ldd 34,x
 0567 C3000A            addd #10
 056A 1AEE2C            ldy 44,x
 056D 3C                pshx
 056E 8F                xgdx
 056F CC0004            ldd #4
 0572 BD0000            jsr __asgnblk
 0575 38                pulx
 0576                 kernel.470::	
                       ; 
                       ;    // insert new message into list in time order
                       ;    if(po_mail_p==NULL) {
 0576 FC0010            ldd _po_mail_p
 0579 2615              bne L76
 057B                 kernel.473::	
                       ; 
                       ;       // we are the first message in PO
                       ;       po_mail_p=new_mail_p;
 057B EC22              ldd 34,x
 057D FD0010            std _po_mail_p
 0580                 kernel.474::	
                       ;       new_mail_p->next=NULL;
 0580 EC22              ldd 34,x
 0582 C3000E            addd #14
 0585 188F              xgdy
 0587 CC0000            ldd #0
 058A 18ED00            std 0,y
 058D                 kernel.476::	
                       ; 
                       ;    } else if(clock_compare(po_mail_p->delivery_time,new_mail_p->delivery_time)>0) {
 058D 7E0684            jmp L77
 0590                 L76:
 0590 EC00              ldd 0,x
 0592 C30014            addd #20
 0595 37                pshb ; 
 0596 36                psha ; spill
 0597 EC22              ldd 34,x
 0599 C30006            addd #6
 059C 188F              xgdy
 059E 32                pula ; 
 059F 33                pulb ; reload
 05A0 3C                pshx
 05A1 8F                xgdx
 05A2 CC0004            ldd #4
 05A5 BD0000            jsr __asgnblk
 05A8 38                pulx
 05A9 EC00              ldd 0,x
 05AB C30014            addd #20
 05AE 37                pshb
 05AF 36                psha
 05B0 EC00              ldd 0,x
 05B2 C30010            addd #16
 05B5 37                pshb ; 
 05B6 36                psha ; spill
 05B7 FC0010            ldd _po_mail_p
 05BA C30006            addd #6
 05BD 188F              xgdy
 05BF 32                pula ; 
 05C0 33                pulb ; reload
 05C1 3C                pshx
 05C2 8F                xgdx
 05C3 CC0004            ldd #4
 05C6 BD0000            jsr __asgnblk
 05C9 38                pulx
 05CA EC00              ldd 0,x
 05CC C30010            addd #16
 05CF BD0000            jsr _clock_compare
 05D2 1838              puly
 05D4 ED02              std 2,x
 05D6 6D03              tst 3,x
 05D8 2F15              ble L78
 05DA                 kernel.479::	
                       ; 
                       ;       // advance to the head of the class!
                       ;       new_mail_p->next=po_mail_p;
 05DA EC22              ldd 34,x
 05DC C3000E            addd #14
 05DF 188F              xgdy
 05E1 FC0010            ldd _po_mail_p
 05E4 18ED00            std 0,y
 05E7                 kernel.480::	
                       ;       po_mail_p=new_mail_p;
 05E7 EC22              ldd 34,x
 05E9 FD0010            std _po_mail_p
 05EC                 kernel.482::	
                       ; 
                       ;    } else {
 05EC 7E0684            jmp L79
 05EF                 L78:
 05EF                 kernel.485::	
                       ; 
                       ;       // we are one of many messages in the PO
                       ;       PRESTO_MESSAGE_T * msg_p=po_mail_p;
 05EF FC0010            ldd _po_mail_p
 05F2 ED0E              std 14,x
 05F4 205B              bra L81
 05F6                 L80:
 05F6                 kernel.487::	
                       ;       while(msg_p->next!=NULL) {
                       ;          if(clock_compare(msg_p->next->delivery_time,new_mail_p->delivery_time)>0) break;
 05F6 EC00              ldd 0,x
 05F8 C3000A            addd #10
 05FB 37                pshb ; 
 05FC 36                psha ; spill
 05FD EC22              ldd 34,x
 05FF C30006            addd #6
 0602 188F              xgdy
 0604 32                pula ; 
 0605 33                pulb ; reload
 0606 3C                pshx
 0607 8F                xgdx
 0608 CC0004            ldd #4
 060B BD0000            jsr __asgnblk
 060E 38                pulx
 060F EC00              ldd 0,x
 0611 C3000A            addd #10
 0614 37                pshb
 0615 36                psha
 0616 EC0E              ldd 14,x
 0618 C3000E            addd #14
 061B 188F              xgdy
 061D 18EC00            ldd 0,y
 0620 C30006            addd #6
 0623 188F              xgdy
 0625 EC00              ldd 0,x
 0627 C30006            addd #6
 062A 3C                pshx
 062B 8F                xgdx
 062C CC0004            ldd #4
 062F BD0000            jsr __asgnblk
 0632 38                pulx
 0633 EC00              ldd 0,x
 0635 C30006            addd #6
 0638 BD0000            jsr _clock_compare
 063B 1838              puly
 063D ED04              std 4,x
 063F 6D05              tst 5,x
 0641 2F02              ble L83
 0643 201B              bra L82
 0645                 L83:
 0645                 kernel.488::	
                       ;          msg_p=msg_p->next;
 0645 EC0E              ldd 14,x
 0647 C3000E            addd #14
 064A 188F              xgdy
 064C 18EC00            ldd 0,y
 064F ED0E              std 14,x
 0651                 kernel.489::	
                       ;       }
 0651                 L81:
 0651 EC0E              ldd 14,x
 0653 C3000E            addd #14
 0656 188F              xgdy
 0658 18EC00            ldd 0,y
 065B 2703              beq X4
 065D 7E05F6            jmp L80
 0660                 X4:
 0660                 L82:
 0660                 kernel.493::	
                       ; 
                       ;       // msg_p->next is either NULL or later delivery time than us
                       ;       // either way, we want to get inserted between msg_p and msg_p->next
                       ;       new_mail_p->next=msg_p->next;
 0660 EC0E              ldd 14,x
 0662 C3000E            addd #14
 0665 188F              xgdy
 0667 18EC00            ldd 0,y
 066A 37                pshb ; 
 066B 36                psha ; spill
 066C EC22              ldd 34,x
 066E C3000E            addd #14
 0671 188F              xgdy
 0673 32                pula ; 
 0674 33                pulb ; reload
 0675 18ED00            std 0,y
 0678                 kernel.494::	
                       ;       msg_p->next=new_mail_p;
 0678 EC0E              ldd 14,x
 067A C3000E            addd #14
 067D 188F              xgdy
 067F EC22              ldd 34,x
 0681 18ED00            std 0,y
 0684                 kernel.495::	
                       ;    }
 0684                 L79:
 0684                 L77:
 0684 0E                    cli
 0685                 kernel.500::	
                       ; 
                       ;    // we're done messing with the PO mail list... interrupts back on
                       ;    INTR_ON();
                       ; 
                       ;    return 0;
 0685 CC0000            ldd #0
 0688 8F                xgdx
 0689 C30024            addd #36
 068C 8F                xgdx
 068D 35                txs
 068E 38                pulx
 068F 1838              puly
 0691 39                rts
 0692                 L71:
 0692 8F                xgdx
 0693 C30024            addd #36
 0696 8F                xgdx
 0697 35                txs
 0698 38                pulx
 0699 1838              puly
 069B 39                rts
                       ;  IX -> 0,x
                       ;          msg_p -> 2,x
                       ;      payload_p -> 6,x
 069C                 _presto_wait_for_message::
 069C BD0000            jsr __enterb
 069F 44                .byte 0x44
 06A0 0F                    sei
 06A1                 kernel.512::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; BYTE presto_wait_for_message(PRESTO_MAIL_T * payload_p) {
                       ;    PRESTO_MESSAGE_T * msg_p;
                       ; 
                       ;    // we're about to switch to a new task... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    // we will only sleep if there are no messages in our queue
                       ;    if(current_tcb_p->mailbox_head==NULL) {
 06A1 FC0006            ldd _current_tcb_p
 06A4 C3000E            addd #14
 06A7 188F              xgdy
 06A9 18EC00            ldd 0,y
 06AC 260F              bne L86
 06AE                 kernel.514::	
                       ;       // no mail, so we can sleep
                       ;       current_tcb_p->state=STATE_BLOCKED;
 06AE FC0006            ldd _current_tcb_p
 06B1 C3000A            addd #10
 06B4 188F              xgdy
 06B6 CC0001            ldd #1
 06B9 18ED00            std 0,y
 06BC 3F                swi
 06BD                 kernel.518::	
                       ;       asm("swi");
                       ;       // When we wake up, we'll be ready to recieve our mail.
                       ;       // Interrupts will be enabled.
                       ;    }
 06BD                 L86:
 06BD 0F                    sei
 06BE                 kernel.523::	
                       ; 
                       ;    // we're about to mess with the mail list... interrupts off
                       ;    INTR_OFF();
                       ;    // we're going to use this a lot, so dereference now
                       ;    msg_p=current_tcb_p->mailbox_head;
 06BE FC0006            ldd _current_tcb_p
 06C1 C3000E            addd #14
 06C4 188F              xgdy
 06C6 18EC00            ldd 0,y
 06C9 ED02              std 2,x
 06CB                 kernel.528::	
                       ; 
                       ;    // AIGH! - this is where the error happens
                       ; 
                       ;    // get one message from the task's mail queue
                       ;    if(msg_p==NULL) {
 06CB EC02              ldd 2,x
 06CD 2603              bne L88
 06CF                 kernel.530::	
                       ;       // there are no messages in the task's mail list
                       ;       presto_fatal_error();
 06CF BD0000            jsr _presto_fatal_error
 06D2                 kernel.531::	
                       ;    }
 06D2                 L88:
 06D2                 kernel.534::	
                       ; 
                       ;    // are we being paranoid?
                       ;    if((msg_p->to_tcb_p)!=current_tcb_p) {
 06D2 EC02              ldd 2,x
 06D4 C30004            addd #4
 06D7 188F              xgdy
 06D9 18EC00            ldd 0,y
 06DC 1AB30006          cpd _current_tcb_p
 06E0 2703              beq L90
 06E2                 kernel.535::	
                       ;       presto_fatal_error();
 06E2 BD0000            jsr _presto_fatal_error
 06E5                 kernel.536::	
                       ;    }
 06E5                 L90:
 06E5                 kernel.539::	
                       ; 
                       ;    // there is at least one message, get one
                       ;    if (msg_p==current_tcb_p->mailbox_tail) {
 06E5 FC0006            ldd _current_tcb_p
 06E8 C30010            addd #16
 06EB 188F              xgdy
 06ED EC02              ldd 2,x
 06EF CDA300            cpd 0,y
 06F2 261E              bne L92
 06F4                 kernel.541::	
                       ;       // there is only one item in the list, take it
                       ;       current_tcb_p->mailbox_head=NULL;
 06F4 FC0006            ldd _current_tcb_p
 06F7 C3000E            addd #14
 06FA 188F              xgdy
 06FC CC0000            ldd #0
 06FF 18ED00            std 0,y
 0702                 kernel.542::	
                       ;       current_tcb_p->mailbox_tail=NULL;
 0702 FC0006            ldd _current_tcb_p
 0705 C30010            addd #16
 0708 188F              xgdy
 070A CC0000            ldd #0
 070D 18ED00            std 0,y
 0710                 kernel.543::	
                       ;    } else {
 0710 2019              bra L93
 0712                 L92:
 0712                 kernel.545::	
                       ;       // there are many messages, take first
                       ;       current_tcb_p->mailbox_head=msg_p->next;
 0712 EC02              ldd 2,x
 0714 C3000E            addd #14
 0717 188F              xgdy
 0719 18EC00            ldd 0,y
 071C 37                pshb ; 
 071D 36                psha ; spill
 071E FC0006            ldd _current_tcb_p
 0721 C3000E            addd #14
 0724 188F              xgdy
 0726 32                pula ; 
 0727 33                pulb ; reload
 0728 18ED00            std 0,y
 072B                 kernel.546::	
                       ;    }
 072B                 L93:
 072B                 kernel.549::	
                       ; 
                       ;    // record the message id before we can get interrupted
                       ;    if(payload_p!=NULL) *payload_p=msg_p->payload;
 072B EC06              ldd 6,x
 072D 2712              beq L94
 072F EC02              ldd 2,x
 0731 C3000A            addd #10
 0734 188F              xgdy
 0736 EC06              ldd 6,x
 0738 3C                pshx
 0739 8F                xgdx
 073A CC0004            ldd #4
 073D BD0000            jsr __asgnblk
 0740 38                pulx
 0741                 L94:
 0741                 kernel.552::	
                       ; 
                       ;    // return the message to the free list
                       ;    msg_p->next=free_mail_p;
 0741 EC02              ldd 2,x
 0743 C3000E            addd #14
 0746 188F              xgdy
 0748 FC000E            ldd _free_mail_p
 074B 18ED00            std 0,y
 074E                 kernel.553::	
                       ;    free_mail_p=msg_p;
 074E EC02              ldd 2,x
 0750 FD000E            std _free_mail_p
 0753 0E                    cli
 0754                 kernel.559::	
                       ; 
                       ;    // done messing with mail lists... interrupts back on
                       ;    INTR_ON();
                       ; 
                       ;    // return the number of messages retrieved
                       ;    return 1;
 0754 CC0001            ldd #1
 0757 8F                xgdx
 0758 C30004            addd #4
 075B 8F                xgdx
 075C 35                txs
 075D 38                pulx
 075E 1838              puly
 0760 39                rts
 0761                 L85:
 0761 8F                xgdx
 0762 C30004            addd #4
 0765 8F                xgdx
 0766 35                txs
 0767 38                pulx
 0768 1838              puly
 076A 39                rts
                       ;  IX -> 0,x
                       ;  func temp: 2,x - 4,x
                       ;          ?temp -> 4,x
                       ;          ?temp -> 8,x
                       ;          count -> 13,x
                       ;          msg_p -> 14,x
                       ;          tcb_p -> 16,x
 076B                 _deliver_mail::
 076B BD0000            jsr __enterb
 076E 12                .byte 0x12
 076F                 kernel.565::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ BYTE deliver_mail(void) {
                       ;    BYTE count=0;
 076F 6F0D              clr 13,x
 0771 7E0803            jmp L98
 0774                 L97:
 0774                 kernel.570::	
                       ;    PRESTO_MESSAGE_T * msg_p;
                       ;    PRESTO_TCB_T * tcb_p;
                       ;    while((po_mail_p!=NULL)&&(clock_compare(po_mail_p->delivery_time,presto_master_clock)<=0)) {
                       ;       // we're going to use this a lot, so de-reference once
                       ;       tcb_p=po_mail_p->to_tcb_p;
 0774 FC0010            ldd _po_mail_p
 0777 C30004            addd #4
 077A 188F              xgdy
 077C 18EC00            ldd 0,y
 077F ED10              std 16,x
 0781                 kernel.571::	
                       ;       if(tcb_p==NULL) presto_fatal_error();
 0781 EC10              ldd 16,x
 0783 2603              bne L100
 0785 BD0000            jsr _presto_fatal_error
 0788                 L100:
 0788                 kernel.574::	
                       ; 
                       ;       // make receiver task ready
                       ;       tcb_p->state=STATE_READY;
 0788 EC10              ldd 16,x
 078A C3000A            addd #10
 078D 188F              xgdy
 078F CC0000            ldd #0
 0792 18ED00            std 0,y
 0795                 kernel.577::	
                       ; 
                       ;       // remove message from PO list
                       ;       msg_p=po_mail_p;                      // we know that po_mail_p!=NULL
 0795 FC0010            ldd _po_mail_p
 0798 ED0E              std 14,x
 079A                 kernel.578::	
                       ;       po_mail_p=po_mail_p->next;
 079A FC0010            ldd _po_mail_p
 079D C3000E            addd #14
 07A0 188F              xgdy
 07A2 18EC00            ldd 0,y
 07A5 FD0010            std _po_mail_p
 07A8                 kernel.581::	
                       ; 
                       ;       // move the message to the task's mail list
                       ;       if(tcb_p->mailbox_head==NULL) {
 07A8 EC10              ldd 16,x
 07AA C3000E            addd #14
 07AD 188F              xgdy
 07AF 18EC00            ldd 0,y
 07B2 261A              bne L102
 07B4                 kernel.584::	
                       ; 
                       ;          // we are the only message in the list
                       ;          tcb_p->mailbox_head=msg_p;
 07B4 EC10              ldd 16,x
 07B6 C3000E            addd #14
 07B9 188F              xgdy
 07BB EC0E              ldd 14,x
 07BD 18ED00            std 0,y
 07C0                 kernel.585::	
                       ;          tcb_p->mailbox_tail=msg_p;
 07C0 EC10              ldd 16,x
 07C2 C30010            addd #16
 07C5 188F              xgdy
 07C7 EC0E              ldd 14,x
 07C9 18ED00            std 0,y
 07CC                 kernel.587::	
                       ; 
                       ;       } else {
 07CC 2020              bra L103
 07CE                 L102:
 07CE                 kernel.590::	
                       ; 
                       ;          // we are one of many, add to the tail of the list
                       ;          tcb_p->mailbox_tail->next=msg_p;
 07CE EC10              ldd 16,x
 07D0 C30010            addd #16
 07D3 188F              xgdy
 07D5 18EC00            ldd 0,y
 07D8 C3000E            addd #14
 07DB 188F              xgdy
 07DD EC0E              ldd 14,x
 07DF 18ED00            std 0,y
 07E2                 kernel.591::	
                       ;          tcb_p->mailbox_tail=msg_p;
 07E2 EC10              ldd 16,x
 07E4 C30010            addd #16
 07E7 188F              xgdy
 07E9 EC0E              ldd 14,x
 07EB 18ED00            std 0,y
 07EE                 kernel.593::	
                       ; 
                       ;       }
 07EE                 L103:
 07EE                 kernel.595::	
                       ;       // no matter what, we are the last in the task's message list
                       ;       msg_p->next=NULL;
 07EE EC0E              ldd 14,x
 07F0 C3000E            addd #14
 07F3 188F              xgdy
 07F5 CC0000            ldd #0
 07F8 18ED00            std 0,y
 07FB                 kernel.598::	
                       ; 
                       ;       // indicate that we moved one mail message
                       ;       count++;
 07FB E60D              ldab 13,x
 07FD 4F                clra
 07FE C30001            addd #1
 0801 E70D              stab 13,x
 0803                 kernel.599::	
                       ;    }
 0803                 L98:
 0803 FC0010            ldd _po_mail_p
 0806 2746              beq L104
 0808 EC00              ldd 0,x
 080A C30008            addd #8
 080D 18CE0175          ldy #_presto_master_clock
 0811 3C                pshx
 0812 8F                xgdx
 0813 CC0004            ldd #4
 0816 BD0000            jsr __asgnblk
 0819 38                pulx
 081A EC00              ldd 0,x
 081C C30008            addd #8
 081F 37                pshb
 0820 36                psha
 0821 EC00              ldd 0,x
 0823 C30004            addd #4
 0826 37                pshb ; 
 0827 36                psha ; spill
 0828 FC0010            ldd _po_mail_p
 082B C30006            addd #6
 082E 188F              xgdy
 0830 32                pula ; 
 0831 33                pulb ; reload
 0832 3C                pshx
 0833 8F                xgdx
 0834 CC0004            ldd #4
 0837 BD0000            jsr __asgnblk
 083A 38                pulx
 083B EC00              ldd 0,x
 083D C30004            addd #4
 0840 BD0000            jsr _clock_compare
 0843 1838              puly
 0845 ED02              std 2,x
 0847 6D03              tst 3,x
 0849 2E03              bgt X5
 084B 7E0774            jmp L97
 084E                 X5:
 084E                 L104:
 084E                 kernel.600::	
                       ;    return count;
 084E E60D              ldab 13,x
 0850 4F                clra
 0851 8F                xgdx
 0852 C30012            addd #18
 0855 8F                xgdx
 0856 35                txs
 0857 38                pulx
 0858 39                rts
 0859                 L96:
 0859 8F                xgdx
 085A C30012            addd #18
 085D 8F                xgdx
 085E 35                txs
 085F 38                pulx
 0860 39                rts
                       ;  IX -> 0,x
 0861                 _idle_task::
 0861                 kernel.607::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   I D L E   T A S K
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ void idle_task(void) {
 0861                 L106:
 0861                 kernel.610::	
                       ;    while(1) {
                       ;       // do nothing
                       ;    }
 0861                 L107:
 0861 20FE              bra L106
 0863                 L105:
 0863 39                rts
                       ;  IX -> 0,x
                       ;            tid -> 5,x
 0864                 _tid_to_tcbptr::
 0864 37                pshb
 0865 36                psha
 0866 3C                pshx
 0867 30                tsx
 0868 3C                pshx
 0869 30                tsx
 086A EC04              ldd 4,x
 086C E705              stab 5,x
 086E                 kernel.618::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   U T I L I T I E S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ PRESTO_TCB_T * tid_to_tcbptr(BYTE tid) {
                       ;    if(tid>=MAX_TASKS) presto_fatal_error();
 086E E605              ldab 5,x
 0870 C106              cmpb #6
 0872 2503              blo L110
 0874 BD0000            jsr _presto_fatal_error
 0877                 L110:
 0877                 kernel.619::	
                       ;    if(tcb_list[tid].state==STATE_INACTIVE) return NULL;
 0877 E605              ldab 5,x
 0879 4F                clra
 087A 188F              xgdy
 087C CC0012            ldd #18
 087F BD0000            jsr __muli
 0882 C30183            addd #_tcb_list+10
 0885 188F              xgdy
 0887 18EC00            ldd 0,y
 088A 1A830002          cpd #2
 088E 260D              bne L112
 0890 CC0000            ldd #0
 0893 8F                xgdx
 0894 C30002            addd #2
 0897 8F                xgdx
 0898 35                txs
 0899 38                pulx
 089A 1838              puly
 089C 39                rts
 089D                 L112:
 089D                 kernel.620::	
                       ;    return &tcb_list[tid];
 089D E605              ldab 5,x
 089F 4F                clra
 08A0 188F              xgdy
 08A2 CC0012            ldd #18
 08A5 BD0000            jsr __muli
 08A8 C30179            addd #_tcb_list
 08AB 8F                xgdx
 08AC C30002            addd #2
 08AF 8F                xgdx
 08B0 35                txs
 08B1 38                pulx
 08B2 1838              puly
 08B4 39                rts
 08B5                 L109:
 08B5 8F                xgdx
 08B6 C30002            addd #2
 08B9 8F                xgdx
 08BA 35                txs
 08BB 38                pulx
 08BC 1838              puly
 08BE 39                rts
                       ;  IX -> 0,x
                       ;  rMEM -> 2,x
 08BF                 _presto_start_master_timer::
 08BF BD0000            jsr __enterb
 08C2 04                .byte 0x4
 08C3                 kernel.629::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   H A R D W A R E   T I M E R / C O U N T E R
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ void presto_start_master_timer(void) {
                       ;    // store (current plus CYCLES_PER_TICK)
                       ;    TOC2 = TCNT + CYCLES_PER_TICK;
 08C3 CC07D0            ldd #2000
 08C6 18CE0064          ldy #100
 08CA BD0000            jsr __muli
 08CD ED02              std 2,x
 08CF FC100E            ldd 0x100e ; vol
 08D2 E302              addd 2,x
 08D4 FD1018            std 0x1018
 08D7                 kernel.631::	
                       ;    // request output compare interrupt
                       ;    TMSK1 |= TMSK1_OC2I;
 08D7 18CE1022          ldy #0x1022
 08DB 181C0040          bset 0,y,#64
 08DF                 kernel.634::	
                       ;    // clear the OUTPUT COMPARE flag
                       ;    // writing O's makes no change, writing 1's clears the bit
                       ;    TFLG1 = TFLG1_OC2F;
 08DF C640              ldab #64
 08E1 F71023            stab 0x1023
 08E4                 kernel.636::	
                       ;    // counter disconnected from output pin logic
                       ;    TCTL1 &= ~(TCTL1_OM2|TCTL1_OL2);
 08E4 18CE1020          ldy #0x1020
 08E8 181D00C0          bclr 0,y,~#-193
 08EC                 kernel.637::	
                       ; }
 08EC                 L115:
 08EC 8F                xgdx
 08ED C30004            addd #4
 08F0 8F                xgdx
 08F1 35                txs
 08F2 38                pulx
 08F3 39                rts
                       ;  IX -> 0,x
                       ;  rMEM -> 2,x
 08F4                 _presto_restart_master_timer::
 08F4 BD0000            jsr __enterb
 08F7 04                .byte 0x4
 08F8                 kernel.643::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ void presto_restart_master_timer(void) {
                       ;    // store (last plus CYCLES_PER_TICK)
                       ;    TOC2 = TOC2 + CYCLES_PER_TICK;
 08F8 CC07D0            ldd #2000
 08FB 18CE0064          ldy #100
 08FF BD0000            jsr __muli
 0902 ED02              std 2,x
 0904 FC1018            ldd 0x1018 ; vol
 0907 E302              addd 2,x
 0909 FD1018            std 0x1018
 090C                 kernel.646::	
                       ;    // clear the OUTPUT COMPARE flag
                       ;    // writing O's makes no change, writing 1's clears the bit
                       ;    TFLG1 = TFLG1_OC2F;
 090C C640              ldab #64
 090E F71023            stab 0x1023
 0911                 kernel.647::	
                       ; }
 0911                 L116:
 0911 8F                xgdx
 0912 C30004            addd #4
 0915 8F                xgdx
 0916 35                txs
 0917 38                pulx
 0918 39                rts
                         .area bss
 0000                 _mail_list::
 0000                   .blkb 320
 0140                 _idle_tid::
 0140                   .blkb 1
 0141                 _idle_tcb_p::
 0141                   .blkb 2
 0143                 _idle_stack::
 0143                   .blkb 50
 0175                 _presto_master_clock::
 0175                   .blkb 4
 0179                 _tcb_list::
 0179                   .blkb 108
 01E5                 _global_save_sp::
 01E5                   .blkb 2
