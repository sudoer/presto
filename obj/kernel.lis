                         .area data
 0000                 _global_new_sp::
 0000                   .blkb 2
                         .area idata
 0000 0000              .word 0
                         .area data
 0002                 _global_old_sp_p::
 0002                   .blkb 2
                         .area idata
 0002 0000              .word 0
                         .area data
 0004                 _global_new_fn::
 0004                   .blkb 2
                         .area idata
 0004 0000              .word 0
                         .area data
 0006                 _current_tcb_p::
 0006                   .blkb 2
                         .area idata
 0006 0000              .word 0
                         .area data
 0008                 _current_tid::
 0008                   .blkb 1
                         .area idata
 0008 00                .byte 0
                         .area data
 0009                 _tcb_head_p::
 0009                   .blkb 2
                         .area idata
 0009 0000              .word 0
                         .area data
 000B                 _free_tcb_p::
 000B                   .blkb 2
                         .area idata
 000B 0000              .word 0
                         .area data
 000D                 _presto_initialized::
 000D                   .blkb 1
                         .area idata
 000D 00                .byte 0
                         .area data
 000E                 _free_mail_p::
 000E                   .blkb 2
                         .area idata
 000E 0000              .word 0
                         .area data
 0010                 _po_mail_p::
 0010                   .blkb 2
                         .area idata
 0010 0000              .word 0
                         .area text
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
                       ;          count -> 7,x
 0000                 _presto_init::
 0000 BD0000            jsr __enterb
 0003 08                .byte 0x8
 0004                 kernel.80::	
                       ; 
                       ; #include "hc11regs.h"
                       ; #include "system.h"
                       ; #include "presto.h"
                       ; #include "kernel\kernel.h"
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #define CYCLES_PER_MS     2000
                       ; #define MS_PER_TICK       100
                       ; #define CYCLES_PER_TICK   CYCLES_PER_MS*MS_PER_TICK
                       ; #define IDLE_PRIORITY     0
                       ; #define IDLE_STACK_SIZE   50
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #define DISABLE_CCR_INTERRUPT_BIT      asm("oraa #0x10");
                       ; #define ENABLE_CCR_INTERRUPT_BIT      asm("anda ~#0x10");
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // GLOBAL VARIABLES
                       ; // These are used to pass arguments to inline assembly routines
                       ; 
                       ; /*static*/ BYTE * global_new_sp=NULL;
                       ; /*static*/ BYTE ** global_old_sp_p=NULL;
                       ; /*static*/ void (*global_new_fn)(void)=NULL;
                       ; /*static*/ BYTE * global_save_sp;     // do not put this on the stack (BOOM)
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // STATIC GLOBAL VARIABLES
                       ; 
                       ; /*static*/ PRESTO_TCB_T * current_tcb_p=NULL;
                       ; /*static*/ PRESTO_TID_T current_tid=0;
                       ; /*static*/ PRESTO_TCB_T * tcb_head_p=NULL;
                       ; /*static*/ PRESTO_TCB_T * free_tcb_p=NULL;
                       ; /*static*/ PRESTO_TCB_T tcb_list[MAX_TASKS];
                       ; 
                       ; /*static*/ PRESTO_TIME_T presto_master_clock;
                       ; /*static*/ BYTE presto_initialized=0;
                       ; 
                       ; // idle task stuff
                       ; /*static*/ BYTE idle_stack[IDLE_STACK_SIZE];
                       ; /*static*/ PRESTO_TCB_T * idle_tcb_p;
                       ; /*static*/ BYTE idle_tid;
                       ; 
                       ; // mail stuff
                       ; /*static*/ PRESTO_MESSAGE_T * free_mail_p=NULL;
                       ; /*static*/ PRESTO_MESSAGE_T * po_mail_p=NULL;
                       ; /*static*/ PRESTO_MESSAGE_T mail_list[MAX_MESSAGES];
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; // FUNCTION PROTOTYPES
                       ; 
                       ; /*static*/ PRESTO_TCB_T * presto_next_tcb_to_run(void);
                       ; /*static*/ void presto_start_master_timer(void);
                       ; /*static*/ void presto_restart_master_timer(void);
                       ; /*static*/ void idle_task(void);
                       ; /*static*/ BYTE deliver_mail(void);
                       ; /*static*/ PRESTO_TCB_T * tid_to_tcbptr(BYTE tid);
                       ; /*static*/ void print_tcb_list(void);
                       ; /*static*/ void print_mail_list(void);
                       ; /*static*/ void idle_task(void);
                       ; 
                       ; void presto_system_isr_wrapper(void);
                       ; void presto_system_isr(void);
                       ; void context_switch_wrapper(void);
                       ; void context_switch(void);
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   I N I T I A L I Z A T I O N
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void presto_init(void) {
                       ;    BYTE count;
                       ; 
                       ;    // initialize once and only once
                       ;    if(presto_initialized) return;
 0004 7D000D            tst _presto_initialized
 0007 2703              beq L12
 0009 7E00F4            jmp L11
 000C                 L12:
 000C                 kernel.81::	
                       ;    presto_initialized++;
 000C F6000D            ldab _presto_initialized
 000F 4F                clra
 0010 C30001            addd #1
 0013 F7000D            stab _presto_initialized
 0016                 kernel.84::	
                       ; 
                       ;    // initialize master clock
                       ;    presto_master_clock=clock_reset();
 0016 CC0175            ldd #_presto_master_clock
 0019 BD0000            jsr _clock_reset
 001C                 kernel.87::	
                       ; 
                       ;    // initialize TCB list
                       ;    for(count=0;count<MAX_TASKS;count++) {
 001C 6F07              clr 7,x
 001E 2050              bra L17
 0020                 L14:
 0020                 kernel.88::	
                       ;       tcb_list[count].next=&tcb_list[count+1];
 0020 E607              ldab 7,x
 0022 4F                clra
 0023 188F              xgdy
 0025 CC0012            ldd #18
 0028 BD0000            jsr __muli
 002B ED04              std 4,x
 002D C30185            addd #_tcb_list+12
 0030 188F              xgdy
 0032 EC04              ldd 4,x
 0034 C3018B            addd #_tcb_list+18
 0037 18ED00            std 0,y
 003A                 kernel.89::	
                       ;       tcb_list[count].task_id=count;
 003A E607              ldab 7,x
 003C 4F                clra
 003D ED02              std 2,x
 003F CC0012            ldd #18
 0042 1AEE02            ldy 2,x
 0045 BD0000            jsr __muli
 0048 C30179            addd #_tcb_list
 004B 188F              xgdy
 004D E603              ldab 3,x
 004F 18E700            stab 0,y
 0052                 kernel.90::	
                       ;       tcb_list[count].state=STATE_INACTIVE;
 0052 E607              ldab 7,x
 0054 4F                clra
 0055 188F              xgdy
 0057 CC0012            ldd #18
 005A BD0000            jsr __muli
 005D C30183            addd #_tcb_list+10
 0060 188F              xgdy
 0062 CC0002            ldd #2
 0065 18ED00            std 0,y
 0068                 kernel.91::	
                       ;    }
 0068                 L15:
 0068 E607              ldab 7,x
 006A 4F                clra
 006B C30001            addd #1
 006E E707              stab 7,x
 0070                 L17:
 0070 E607              ldab 7,x
 0072 C106              cmpb #6
 0074 25AA              blo L14
 0076                 kernel.92::	
                       ;    tcb_list[MAX_TASKS-1].next=NULL;
 0076 CC0000            ldd #0
 0079 FD01DF            std _tcb_list+90+12
 007C                 kernel.93::	
                       ;    free_tcb_p=&tcb_list[0];
 007C CC0179            ldd #_tcb_list
 007F FD000B            std _free_tcb_p
 0082                 kernel.96::	
                       ; 
                       ;    // initialize mail list
                       ;    for(count=0;count<MAX_MESSAGES;count++) {
 0082 6F07              clr 7,x
 0084 2031              bra L26
 0086                 L23:
 0086                 kernel.97::	
                       ;       mail_list[count].next=&mail_list[count+1];  // goes past end of array - OK
 0086 E607              ldab 7,x
 0088 4F                clra
 0089 05                lsld
 008A 05                lsld
 008B 05                lsld
 008C 05                lsld
 008D ED04              std 4,x
 008F C3000E            addd #_mail_list+14
 0092 188F              xgdy
 0094 EC04              ldd 4,x
 0096 C30010            addd #_mail_list+16
 0099 18ED00            std 0,y
 009C                 kernel.98::	
                       ;       mail_list[count].serial_number=count;
 009C E607              ldab 7,x
 009E 4F                clra
 009F ED02              std 2,x
 00A1 05                lsld
 00A2 05                lsld
 00A3 05                lsld
 00A4 05                lsld
 00A5 C30000            addd #_mail_list
 00A8 188F              xgdy
 00AA EC02              ldd 2,x
 00AC 18ED00            std 0,y
 00AF                 kernel.99::	
                       ;    }
 00AF                 L24:
 00AF E607              ldab 7,x
 00B1 4F                clra
 00B2 C30001            addd #1
 00B5 E707              stab 7,x
 00B7                 L26:
 00B7 E607              ldab 7,x
 00B9 C114              cmpb #20
 00BB 25C9              blo L23
 00BD                 kernel.100::	
                       ;    mail_list[MAX_MESSAGES-1].next=NULL;
 00BD CC0000            ldd #0
 00C0 FD013E            std _mail_list+304+14
 00C3                 kernel.101::	
                       ;    free_mail_p=&mail_list[0];
 00C3 CC0000            ldd #_mail_list
 00C6 FD000E            std _free_mail_p
 00C9                 kernel.105::	
                       ; 
                       ;    // initialize idle task
                       ;    // must be done after presto_initialized++ because of initialization check
                       ;    idle_tid=presto_create_task(idle_task,idle_stack,IDLE_STACK_SIZE,IDLE_PRIORITY);
 00C9 CC0000            ldd #0
 00CC 37                pshb
 00CD 36                psha
 00CE CC0032            ldd #50
 00D1 37                pshb
 00D2 36                psha
 00D3 CC0143            ldd #_idle_stack
 00D6 37                pshb
 00D7 36                psha
 00D8 CC0869            ldd #_idle_task
 00DB BD0154            jsr _presto_create_task
 00DE BD0000            jsr __movspb
 00E1 06                .byte 6
 00E2 4F                clra
 00E3 5D                tstb
 00E4 2A01              bpl X0
 00E6 43                coma
 00E7                 X0:
 00E7 F70140            stab _idle_tid
 00EA                 kernel.106::	
                       ;    idle_tcb_p=tid_to_tcbptr(idle_tid);
 00EA F60140            ldab _idle_tid
 00ED 4F                clra
 00EE BD086C            jsr _tid_to_tcbptr
 00F1 FD0141            std _idle_tcb_p
 00F4                 kernel.107::	
                       ; }
 00F4                 L11:
 00F4 8F                xgdx
 00F5 C30008            addd #8
 00F8 8F                xgdx
 00F9 35                txs
 00FA 38                pulx
 00FB 39                rts
                       ;  IX -> 0,x
 00FC                 _presto_start_scheduler::
 00FC                 kernel.113::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void presto_start_scheduler(void) {
                       ; 
                       ;    if(presto_initialized==0) presto_fatal_error();
 00FC 7D000D            tst _presto_initialized
 00FF 2603              bne L32
 0101 BD0000            jsr _presto_fatal_error
 0104                 L32:
 0104 0F                    sei
 0105                 kernel.119::	
                       ; 
                       ;    // we're about to switch to our first task... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    //set_interrupt(INTR_TOC2, presto_system_isr_wrapper);
                       ;    set_interrupt(INTR_TOC2, presto_system_isr);
 0105 CC030C            ldd #_presto_system_isr
 0108 37                pshb
 0109 36                psha
 010A CC0008            ldd #8
 010D BD0000            jsr _set_interrupt
 0110 1838              puly
 0112                 kernel.120::	
                       ;    set_interrupt(INTR_SWI, context_switch);
 0112 CC03AD            ldd #_context_switch
 0115 37                pshb
 0116 36                psha
 0117 CC0010            ldd #16
 011A BD0000            jsr _set_interrupt
 011D 1838              puly
 011F                 kernel.123::	
                       ; 
                       ;    // start timer interrupts for pre-emption
                       ;    presto_start_master_timer();
 011F BD08C7            jsr _presto_start_master_timer
 0122                 kernel.127::	
                       ; 
                       ;    // pick next task to run
                       ;    // first task in list is highest priority and is ready
                       ;    current_tcb_p=tcb_head_p;
 0122 FC0009            ldd _tcb_head_p
 0125 FD0006            std _current_tcb_p
 0128                 kernel.128::	
                       ;    if(current_tcb_p==NULL) {
 0128 FC0006            ldd _current_tcb_p
 012B 2603              bne L34
 012D                 kernel.129::	
                       ;       presto_fatal_error();
 012D BD0000            jsr _presto_fatal_error
 0130                 kernel.130::	
                       ;    }
 0130                 L34:
 0130                 kernel.131::	
                       ;    current_tid=current_tcb_p->task_id;
 0130 18FE0006          ldy _current_tcb_p
 0134 18E600            ldab 0,y
 0137 F70008            stab _current_tid
 013A                 kernel.137::	
                       ; 
                       ;    // SET UP A NEW STACK AND START EXECUTION USING IT
                       ; 
                       ;    // these parameters will be used in inline assembly...
                       ;    // must be put in global space, not on stack
                       ;    global_new_sp=current_tcb_p->stack_ptr;
 013A FC0006            ldd _current_tcb_p
 013D C30002            addd #2
 0140 188F              xgdy
 0142 18EC00            ldd 0,y
 0145 FD0000            std _global_new_sp
 0148 BE0000            lds _global_new_sp
 014B 32                pula
 014C 84EF              anda ~#0x10
 014E 36                psha
 014F 3B                rti
 0150                 kernel.153::	
                       ; 
                       ;    asm("lds _global_new_sp");
                       ; 
                       ;    // Clear interrupt mask bit (to enable ints) in the CC register on the stack.
                       ;    // That way, the new task will have interrupts enabled when it wakes up.
                       ;    asm("pula");
                       ;    ENABLE_CCR_INTERRUPT_BIT;
                       ;    asm("psha");
                       ; 
                       ;    // Normally, this function would end with an RTS, but we want to act EXACTLY
                       ;    // the same as if we had just been inside of an interrupt.  So we manually
                       ;    // call RTI here to pop the registers and "run" the new task.
                       ;    asm("rti");
                       ; 
                       ;    // we never get here
                       ;    presto_fatal_error();
 0150 BD0000            jsr _presto_fatal_error
 0153                 kernel.154::	
                       ; }
 0153                 L31:
 0153 39                rts
                       ;  IX -> 0,x
                       ;            ptr -> 2,x
                       ;      new_tcb_p -> 4,x
                       ;       priority -> 17,x
                       ;     stack_size -> 14,x
                       ;          stack -> 12,x
                       ;           func -> 8,x
 0154                 _presto_create_task::
 0154 BD0000            jsr __enterb
 0157 46                .byte 0x46
 0158 EC10              ldd 16,x
 015A E711              stab 17,x
 015C                 kernel.164::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   T A S K   M A N A G E M E N T
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; PRESTO_TID_T presto_create_task( void (*func)(void), BYTE * stack, short stack_size, BYTE priority ) {
                       ; 
                       ;    PRESTO_TCB_T * new_tcb_p;
                       ; 
                       ;    if(presto_initialized==0) presto_fatal_error();
 015C 7D000D            tst _presto_initialized
 015F 2603              bne L37
 0161 BD0000            jsr _presto_fatal_error
 0164                 L37:
 0164                 kernel.166::	
                       ; 
                       ;    if(free_tcb_p==NULL) {
 0164 FC000B            ldd _free_tcb_p
 0167 2610              bne L39
 0169                 kernel.168::	
                       ;       // There are no more TCB's left.
                       ;       presto_fatal_error();
 0169 BD0000            jsr _presto_fatal_error
 016C                 kernel.169::	
                       ;       return -1;
 016C CCFFFF            ldd #-1
 016F 8F                xgdx
 0170 C30006            addd #6
 0173 8F                xgdx
 0174 35                txs
 0175 38                pulx
 0176 1838              puly
 0178 39                rts
 0179                 L39:
 0179 0F                    sei
 017A                 kernel.176::	
                       ;    }
                       ; 
                       ;    // we're about to mess with tasks, TCB's... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    // allocate TCB for new task
                       ;    new_tcb_p=free_tcb_p;
 017A FC000B            ldd _free_tcb_p
 017D ED04              std 4,x
 017F                 kernel.177::	
                       ;    free_tcb_p=free_tcb_p->next;
 017F FC000B            ldd _free_tcb_p
 0182 C3000C            addd #12
 0185 188F              xgdy
 0187 18EC00            ldd 0,y
 018A FD000B            std _free_tcb_p
 018D                 kernel.181::	
                       ; 
                       ;    // initialize TCB elements
                       ;    // new_tcb_p->task_id is already assigned
                       ;    new_tcb_p->stack_top=stack+stack_size-1;
 018D EC04              ldd 4,x
 018F C30004            addd #4
 0192 188F              xgdy
 0194 EC0E              ldd 14,x
 0196 E30C              addd 12,x
 0198 C3FFFF            addd #-1
 019B 18ED00            std 0,y
 019E                 kernel.182::	
                       ;    new_tcb_p->stack_bottom=stack;
 019E EC04              ldd 4,x
 01A0 C30006            addd #6
 01A3 188F              xgdy
 01A5 EC0C              ldd 12,x
 01A7 18ED00            std 0,y
 01AA                 kernel.183::	
                       ;    new_tcb_p->stack_ptr=new_tcb_p->stack_top;
 01AA EC04              ldd 4,x
 01AC C30004            addd #4
 01AF 188F              xgdy
 01B1 18EC00            ldd 0,y
 01B4 37                pshb ; 
 01B5 36                psha ; spill
 01B6 EC04              ldd 4,x
 01B8 C30002            addd #2
 01BB 188F              xgdy
 01BD 32                pula ; 
 01BE 33                pulb ; reload
 01BF 18ED00            std 0,y
 01C2                 kernel.184::	
                       ;    new_tcb_p->priority=priority;
 01C2 EC04              ldd 4,x
 01C4 C30008            addd #8
 01C7 188F              xgdy
 01C9 E611              ldab 17,x
 01CB 18E700            stab 0,y
 01CE                 kernel.185::	
                       ;    new_tcb_p->state=STATE_READY;
 01CE EC04              ldd 4,x
 01D0 C3000A            addd #10
 01D3 188F              xgdy
 01D5 CC0000            ldd #0
 01D8 18ED00            std 0,y
 01DB                 kernel.186::	
                       ;    new_tcb_p->mailbox_head=NULL;
 01DB EC04              ldd 4,x
 01DD C3000E            addd #14
 01E0 188F              xgdy
 01E2 CC0000            ldd #0
 01E5 18ED00            std 0,y
 01E8                 kernel.187::	
                       ;    new_tcb_p->mailbox_tail=NULL;
 01E8 EC04              ldd 4,x
 01EA C30010            addd #16
 01ED 188F              xgdy
 01EF CC0000            ldd #0
 01F2 18ED00            std 0,y
 01F5                 kernel.193::	
                       ; 
                       ;    // SET UP NEW STACK USING ASSEMBLY LANGUAGE
                       ; 
                       ;    // these parameters will be used in inline assembly...
                       ;    // must be put in global space, not on stack
                       ;    global_new_sp=new_tcb_p->stack_ptr;
 01F5 EC04              ldd 4,x
 01F7 C30002            addd #2
 01FA 188F              xgdy
 01FC 18EC00            ldd 0,y
 01FF FD0000            std _global_new_sp
 0202                 kernel.194::	
                       ;    global_new_fn=func;
 0202 EC08              ldd 8,x
 0204 FD0004            std _global_new_fn
 0207 BF01E5            sts _global_save_sp
 020A BE0000            lds _global_new_sp
 020D CC0000            ldd #_presto_fatal_error
 0210 37                pshb
 0211 36                psha
 0212 FC0004            ldd _global_new_fn
 0215 37                pshb
 0216 36                psha
 0217 8600              ldaa #0
 0219 36                psha
 021A 36                psha
 021B 36                psha
 021C 36                psha
 021D 36                psha
 021E 36                psha
 021F 36                psha
 0220 BF0000            sts _global_new_sp
 0223 BE01E5            lds _global_save_sp
 0226                 kernel.231::	
                       ; 
                       ;    // store our own SP so we can work on the new task
                       ;    asm("sts _global_save_sp");
                       ; 
                       ;    // load empty SP from task so we can initialize it
                       ;    asm("lds _global_new_sp");
                       ; 
                       ;    // Set presto_fatal_error as the "return pc" of a new task.  If some bozo
                       ;    // tries to return out of his task's main function, we will cause an alarm.
                       ;    asm("ldd #_presto_fatal_error");
                       ;    asm("pshb");
                       ;    asm("psha");
                       ; 
                       ;    // push the actual function call on the stack
                       ;    asm("ldd _global_new_fn");
                       ;    asm("pshb");
                       ;    asm("psha");
                       ; 
                       ;    // push any old stinkin' registers onto the stack
                       ;    // they'll be pulled off when we start running
                       ;    // we push in interrupt-stack order
                       ;    asm("ldaa #0");
                       ;    asm("psha"); // Y(L) register
                       ;    asm("psha"); // Y(H) register
                       ;    asm("psha"); // X(L) register
                       ;    asm("psha"); // X(H) register
                       ;    asm("psha"); // A register
                       ;    asm("psha"); // B register
                       ;    asm("psha"); // Initial Condition Codes (I bit cleared)
                       ; 
                       ;    // save task SP in TCB
                       ;    asm("sts _global_new_sp");
                       ;    // re-load our own SP so we can return
                       ;    asm("lds _global_save_sp");
                       ; 
                       ;    // recover the altered stack pointer and save it in the TCB
                       ;    new_tcb_p->stack_ptr=global_new_sp;
 0226 EC04              ldd 4,x
 0228 C30002            addd #2
 022B 188F              xgdy
 022D FC0000            ldd _global_new_sp
 0230 18ED00            std 0,y
 0233                 kernel.235::	
                       ; 
                       ;    // INSERT NEW TCB INTO LIST IN PRIORITY ORDER
                       ; 
                       ;    if(tcb_head_p==NULL) {
 0233 FC0009            ldd _tcb_head_p
 0236 2615              bne L41
 0238                 kernel.237::	
                       ;       // we are the first TCB in the list
                       ;       tcb_head_p=new_tcb_p;
 0238 EC04              ldd 4,x
 023A FD0009            std _tcb_head_p
 023D                 kernel.238::	
                       ;       new_tcb_p->next=NULL;
 023D EC04              ldd 4,x
 023F C3000C            addd #12
 0242 188F              xgdy
 0244 CC0000            ldd #0
 0247 18ED00            std 0,y
 024A                 kernel.239::	
                       ;    } else if((new_tcb_p->priority)>(tcb_head_p->priority)) {
 024A 7E02E4            jmp L42
 024D                 L41:
 024D EC04              ldd 4,x
 024F C30008            addd #8
 0252 188F              xgdy
 0254 18E600            ldab 0,y
 0257 37                pshb ; 
 0258 36                psha ; spill
 0259 FC0009            ldd _tcb_head_p
 025C C30008            addd #8
 025F 188F              xgdy
 0261 32                pula ; 
 0262 33                pulb ; reload
 0263 18E100            cmpb 0,y
 0266 2315              bls L43
 0268                 kernel.241::	
                       ;       // advance to the head of the class!
                       ;       new_tcb_p->next=tcb_head_p;
 0268 EC04              ldd 4,x
 026A C3000C            addd #12
 026D 188F              xgdy
 026F FC0009            ldd _tcb_head_p
 0272 18ED00            std 0,y
 0275                 kernel.242::	
                       ;       tcb_head_p=new_tcb_p;
 0275 EC04              ldd 4,x
 0277 FD0009            std _tcb_head_p
 027A                 kernel.243::	
                       ;    } else {
 027A 7E02E4            jmp L44
 027D                 L43:
 027D                 kernel.244::	
                       ;       PRESTO_TCB_T * ptr=tcb_head_p;
 027D FC0009            ldd _tcb_head_p
 0280 ED02              std 2,x
 0282 2030              bra L46
 0284                 L45:
 0284                 kernel.246::	
                       ;       while(ptr->next!=NULL) {
                       ;          if((new_tcb_p->priority)>(ptr->next->priority)) break;
 0284 EC02              ldd 2,x
 0286 C3000C            addd #12
 0289 188F              xgdy
 028B 18EC00            ldd 0,y
 028E C30008            addd #8
 0291 188F              xgdy
 0293 EC04              ldd 4,x
 0295 C30008            addd #8
 0298 183C              pshy ; spill
 029A 188F              xgdy
 029C 18E600            ldab 0,y
 029F 1838              puly ; reload
 02A1 18E100            cmpb 0,y
 02A4 2302              bls L48
 02A6 2018              bra L47
 02A8                 L48:
 02A8                 kernel.247::	
                       ;          ptr=ptr->next;
 02A8 EC02              ldd 2,x
 02AA C3000C            addd #12
 02AD 188F              xgdy
 02AF 18EC00            ldd 0,y
 02B2 ED02              std 2,x
 02B4                 kernel.248::	
                       ;       }
 02B4                 L46:
 02B4 EC02              ldd 2,x
 02B6 C3000C            addd #12
 02B9 188F              xgdy
 02BB 18EC00            ldd 0,y
 02BE 26C4              bne L45
 02C0                 L47:
 02C0                 kernel.252::	
                       ; 
                       ;       // ptr->next is either NULL or lower priority than us
                       ;       // either way, we want to get inserted between ptr and ptr->next
                       ;       new_tcb_p->next=ptr->next;
 02C0 EC02              ldd 2,x
 02C2 C3000C            addd #12
 02C5 188F              xgdy
 02C7 18EC00            ldd 0,y
 02CA 37                pshb ; 
 02CB 36                psha ; spill
 02CC EC04              ldd 4,x
 02CE C3000C            addd #12
 02D1 188F              xgdy
 02D3 32                pula ; 
 02D4 33                pulb ; reload
 02D5 18ED00            std 0,y
 02D8                 kernel.253::	
                       ;       ptr->next=new_tcb_p;
 02D8 EC02              ldd 2,x
 02DA C3000C            addd #12
 02DD 188F              xgdy
 02DF EC04              ldd 4,x
 02E1 18ED00            std 0,y
 02E4                 kernel.254::	
                       ;    }
 02E4                 L44:
 02E4                 L42:
 02E4 0E                    cli
 02E5                 kernel.259::	
                       ; 
                       ;    // we're done messing with the task list... interrupts back on
                       ;    INTR_ON();
                       ; 
                       ;    return new_tcb_p->task_id;
 02E5 1AEE04            ldy 4,x
 02E8 18E600            ldab 0,y
 02EB 4F                clra
 02EC 5D                tstb
 02ED 2A01              bpl X1
 02EF 43                coma
 02F0                 X1:
 02F0 8F                xgdx
 02F1 C30006            addd #6
 02F4 8F                xgdx
 02F5 35                txs
 02F6 38                pulx
 02F7 1838              puly
 02F9 39                rts
 02FA                 L36:
 02FA 8F                xgdx
 02FB C30006            addd #6
 02FE 8F                xgdx
 02FF 35                txs
 0300 38                pulx
 0301 1838              puly
 0303 39                rts
                       ;  IX -> 0,x
 0304                 _presto_kill_self::
 0304                 kernel.266::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void presto_kill_self(void) {
                       ;    // TODO - remove TCB from list
                       ;    presto_fatal_error();
 0304 BD0000            jsr _presto_fatal_error
 0307                 kernel.267::	
                       ; }
 0307                 L50:
 0307 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
 0308                 _presto_system_isr_wrapper::
 0308 BD0000            jsr __enterb
 030B 08                .byte 0x8
 030C                 	_presto_system_isr::
 030C                 kernel.288::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   C O N T E X T   S W I T C H I N G   ( I N T E R R U P T )
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; #pragma interrupt presto_system_isr_wrapper
                       ; void presto_system_isr_wrapper(void) {
                       ; 
                       ;    // The ICC compiler adds a "jsr __enterb" at the beginning of my interrupt
                       ;    // service routine.  Apparently, it is concerned with preserving the state
                       ;    // of the X register, and it tries to push it onto the stack and then do some
                       ;    // funny math.  At the end of the ISR, it tries to undo all of the mess, and
                       ;    // it even ends the ISR with a jump instruction.  Yikes!  I use this label
                       ;    // to by-pass this destructive behavior at the top, and later I use an
                       ;    // inline "RTI" instruction to by-pass the stuff at the bottom.
                       ;    asm("_presto_system_isr::");
                       ; 
                       ;    // interrupts are disabled at this time
                       ; 
                       ;    // take care of clock things
                       ;    presto_master_clock=clock_add(presto_master_clock,MS_PER_TICK);
 030C CC0064            ldd #100
 030F 37                pshb
 0310 36                psha
 0311 EC00              ldd 0,x
 0313 C30004            addd #4
 0316 18CE0175          ldy #_presto_master_clock
 031A 3C                pshx
 031B 8F                xgdx
 031C CC0004            ldd #4
 031F BD0000            jsr __asgnblk
 0322 38                pulx
 0323 EC00              ldd 0,x
 0325 C30004            addd #4
 0328 37                pshb
 0329 36                psha
 032A CC0175            ldd #_presto_master_clock
 032D BD0000            jsr _clock_add
 0330 1838              puly
 0332 1838              puly
 0334                 kernel.289::	
                       ;    presto_restart_master_timer();
 0334 BD08FC            jsr _presto_restart_master_timer
 0337                 kernel.292::	
                       ; 
                       ;    // check mail
                       ;    if(deliver_mail()>0) {
 0337 BD0773            jsr _deliver_mail
 033A C100              cmpb #0
 033C 235F              bls L52
 033E                 kernel.295::	
                       ; 
                       ;       // check to see if we've clobbered our stack
                       ;       if(((current_tcb_p->stack_ptr)>(current_tcb_p->stack_top))
 033E FC0006            ldd _current_tcb_p
 0341 C30002            addd #2
 0344 188F              xgdy
 0346 18EC00            ldd 0,y
 0349 ED02              std 2,x
 034B FC0006            ldd _current_tcb_p
 034E C30004            addd #4
 0351 188F              xgdy
 0353 EC02              ldd 2,x
 0355 CDA300            cpd 0,y
 0358 220F              bhi L56
 035A FC0006            ldd _current_tcb_p
 035D C30006            addd #6
 0360 188F              xgdy
 0362 EC02              ldd 2,x
 0364 CDA300            cpd 0,y
 0367 2403              bhs L54
 0369                 L56:
 0369                 kernel.297::	
                       ;       ||((current_tcb_p->stack_ptr)<(current_tcb_p->stack_bottom)))
                       ;          presto_fatal_error();
 0369 BD0000            jsr _presto_fatal_error
 036C                 L54:
 036C                 kernel.303::	
                       ; 
                       ;       // these parameters will be used in inline assembly...
                       ;       // must be put in global space, not on stack
                       ; 
                       ;       // the ISR will save old SP in old TCB
                       ;       global_old_sp_p=&(current_tcb_p->stack_ptr);
 036C FC0006            ldd _current_tcb_p
 036F C30002            addd #2
 0372 FD0002            std _global_old_sp_p
 0375                 kernel.306::	
                       ; 
                       ;       // pick next task to run
                       ;       current_tcb_p=presto_next_tcb_to_run();
 0375 BD044F            jsr _presto_next_tcb_to_run
 0378 FD0006            std _current_tcb_p
 037B                 kernel.307::	
                       ;       current_tid=current_tcb_p->task_id;
 037B 18FE0006          ldy _current_tcb_p
 037F 18E600            ldab 0,y
 0382 F70008            stab _current_tid
 0385                 kernel.310::	
                       ; 
                       ;       // end of ISR will set up new stack
                       ;       global_new_sp=current_tcb_p->stack_ptr;
 0385 FC0006            ldd _current_tcb_p
 0388 C30002            addd #2
 038B 188F              xgdy
 038D 18EC00            ldd 0,y
 0390 FD0000            std _global_new_sp
 0393 18FE0002          ldy _global_old_sp_p
 0397 18AF00            sts 0,y
 039A BE0000            lds _global_new_sp
 039D                 kernel.316::	
                       ; 
                       ;       // swap the stack pointers
                       ;       asm("ldy _global_old_sp_p");
                       ;       asm("sts 0,y");
                       ;       asm("lds _global_new_sp");
                       ;    }
 039D                 L52:
 039D 3B                rti
 039E                 kernel.336::	
                       ; 
                       ; /*
                       ;    // Clear interrupt mask bit (to enable ints) in the CC register on the stack.
                       ;    // That way, the new task will have interrupts enabled when it wakes up.
                       ;    asm("pula");
                       ;    ENABLE_CCR_INTERRUPT_BIT;
                       ;    asm("psha");
                       ; */
                       ; 
                       ;    // The end of this function SHOULD be an RTI (instead of RTS), because it is
                       ;    // an interrupt.  But the ICC compiler adds a lot of stuff at the beginning
                       ;    // and the end of interrupt service routines.  Specifically, it is messing
                       ;    // with the X register (pushing it onto the stack) because it uses that as
                       ;    // a frame pointer.  So I will add my RTI here explicitly, to force the
                       ;    // behavior that I want.
                       ;    // Now we will pop the stack and "run" the new task.
                       ;    asm("rti");
                       ; 
                       ;    // we never get here
                       ;    presto_fatal_error();
 039E BD0000            jsr _presto_fatal_error
 03A1                 kernel.337::	
                       ; }
 03A1                 L51:
 03A1 8F                xgdx
 03A2 C30008            addd #8
 03A5 8F                xgdx
 03A6 35                txs
 03A7 38                pulx
 03A8 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;          ?temp -> 4,x
 03A9                 _context_switch_wrapper::
 03A9 BD0000            jsr __enterb
 03AC 06                .byte 0x6
 03AD                 	_context_switch::
 03AD                 kernel.346::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; void context_switch_wrapper(void) {
                       ; 
                       ;    asm("_context_switch::");
                       ; 
                       ;    // check to see if the old task has clobbered its stack
                       ;    if(((current_tcb_p->stack_ptr)>(current_tcb_p->stack_top))
 03AD FC0006            ldd _current_tcb_p
 03B0 C30002            addd #2
 03B3 188F              xgdy
 03B5 18EC00            ldd 0,y
 03B8 ED04              std 4,x
 03BA FC0006            ldd _current_tcb_p
 03BD C30004            addd #4
 03C0 188F              xgdy
 03C2 EC04              ldd 4,x
 03C4 CDA300            cpd 0,y
 03C7 220F              bhi L60
 03C9 FC0006            ldd _current_tcb_p
 03CC C30006            addd #6
 03CF 188F              xgdy
 03D1 EC04              ldd 4,x
 03D3 CDA300            cpd 0,y
 03D6 2403              bhs L58
 03D8                 L60:
 03D8                 kernel.348::	
                       ;    ||((current_tcb_p->stack_ptr)<(current_tcb_p->stack_bottom)))
                       ;       presto_fatal_error();
 03D8 BD0000            jsr _presto_fatal_error
 03DB                 L58:
 03DB                 kernel.351::	
                       ; 
                       ;    // the inline asm will save old SP in old TCB
                       ;    global_old_sp_p=&(current_tcb_p->stack_ptr);
 03DB FC0006            ldd _current_tcb_p
 03DE C30002            addd #2
 03E1 FD0002            std _global_old_sp_p
 03E4                 kernel.354::	
                       ; 
                       ;    // pick next task to run
                       ;    current_tcb_p=presto_next_tcb_to_run();
 03E4 BD044F            jsr _presto_next_tcb_to_run
 03E7 FD0006            std _current_tcb_p
 03EA                 kernel.355::	
                       ;    current_tid=current_tcb_p->task_id;
 03EA 18FE0006          ldy _current_tcb_p
 03EE 18E600            ldab 0,y
 03F1 F70008            stab _current_tid
 03F4                 kernel.358::	
                       ; 
                       ;    // check to see if the new task has clobbered its stack
                       ;    if(((current_tcb_p->stack_ptr)>(current_tcb_p->stack_top))
 03F4 FC0006            ldd _current_tcb_p
 03F7 C30002            addd #2
 03FA 188F              xgdy
 03FC 18EC00            ldd 0,y
 03FF ED02              std 2,x
 0401 FC0006            ldd _current_tcb_p
 0404 C30004            addd #4
 0407 188F              xgdy
 0409 EC02              ldd 2,x
 040B CDA300            cpd 0,y
 040E 220F              bhi L63
 0410 FC0006            ldd _current_tcb_p
 0413 C30006            addd #6
 0416 188F              xgdy
 0418 EC02              ldd 2,x
 041A CDA300            cpd 0,y
 041D 2403              bhs L61
 041F                 L63:
 041F                 kernel.360::	
                       ;    ||((current_tcb_p->stack_ptr)<(current_tcb_p->stack_bottom)))
                       ;       presto_fatal_error();
 041F BD0000            jsr _presto_fatal_error
 0422                 L61:
 0422                 kernel.365::	
                       ; 
                       ;    // call asm routine to set up new stack
                       ;    // when we return, we'll be another process
                       ;    // the asm routine will re-enable interrupts
                       ;    global_new_sp=current_tcb_p->stack_ptr;
 0422 FC0006            ldd _current_tcb_p
 0425 C30002            addd #2
 0428 188F              xgdy
 042A 18EC00            ldd 0,y
 042D FD0000            std _global_new_sp
 0430 183C              pshy
 0432 3C                pshx
 0433 36                psha
 0434 37                pshb
 0435 07                tpa
 0436 84EF              anda ~#0x10
 0438 36                psha
 0439 18FE0002          ldy _global_old_sp_p
 043D 18AF00            sts 0,y
 0440 BE0000            lds _global_new_sp
 0443 3B                rti
 0444                 kernel.395::	
                       ; 
                       ;    // save the registers (in the same order that an interrupt does)
                       ;    asm("pshy");  // 2 bytes (Low, then High)
                       ;    asm("pshx");  // 2 bytes (Low, then High)
                       ;    asm("psha");  // 1 byte
                       ;    asm("pshb");  // 1 byte
                       ;    asm("tpa");
                       ;    ENABLE_CCR_INTERRUPT_BIT;  // enable interrupts in pushed CC register
                       ;    asm("psha");  // 1 byte, the condition codes
                       ; 
                       ;    // swap the stack pointers
                       ;    asm("ldy _global_old_sp_p");
                       ;    asm("sts 0,y");
                       ;    asm("lds _global_new_sp");
                       ; 
                       ; /*
                       ;    // Clear interrupt mask bit (to enable ints) in the CC register on the stack.
                       ;    // That way, the new task will have interrupts enabled when it wakes up.
                       ;    asm("pula");
                       ;    ENABLE_CCR_INTERRUPT_BIT;
                       ;    asm("psha");
                       ; */
                       ; 
                       ;    // Normally, this function would end with an RTS, but we want to act EXACTLY
                       ;    // the same as if we had just been inside of an interrupt.  So we manually
                       ;    // call RTI here to pop the registers and "run" the new task.
                       ;    asm("rti");
                       ; 
                       ;    // we never get here
                       ;    presto_fatal_error();
 0444 BD0000            jsr _presto_fatal_error
 0447                 kernel.396::	
                       ; }
 0447                 L57:
 0447 8F                xgdx
 0448 C30006            addd #6
 044B 8F                xgdx
 044C 35                txs
 044D 38                pulx
 044E 39                rts
                       ;  IX -> 0,x
                       ;            ptr -> 2,x
 044F                 _presto_next_tcb_to_run::
 044F BD0000            jsr __enterb
 0452 04                .byte 0x4
 0453                 kernel.405::	
                       ; 
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   S C H E D U L I N G
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ PRESTO_TCB_T * presto_next_tcb_to_run(void) {
                       ;    // pick highest priority ready task to run
                       ;    PRESTO_TCB_T * ptr=tcb_head_p;
 0453 FC0009            ldd _tcb_head_p
 0456 ED02              std 2,x
 0458 2022              bra L66
 045A                 L65:
 045A                 kernel.407::	
                       ;    while(ptr!=NULL) {
                       ;       if(ptr->state==STATE_READY) return ptr;
 045A EC02              ldd 2,x
 045C C3000A            addd #10
 045F 188F              xgdy
 0461 18EC00            ldd 0,y
 0464 260A              bne L68
 0466 EC02              ldd 2,x
 0468 8F                xgdx
 0469 C30004            addd #4
 046C 8F                xgdx
 046D 35                txs
 046E 38                pulx
 046F 39                rts
 0470                 L68:
 0470                 kernel.408::	
                       ;       ptr=ptr->next;
 0470 EC02              ldd 2,x
 0472 C3000C            addd #12
 0475 188F              xgdy
 0477 18EC00            ldd 0,y
 047A ED02              std 2,x
 047C                 kernel.409::	
                       ;    }
 047C                 L66:
 047C EC02              ldd 2,x
 047E 26DA              bne L65
 0480                 kernel.411::	
                       ;    // should never get here
                       ;    presto_fatal_error();
 0480 BD0000            jsr _presto_fatal_error
 0483                 kernel.412::	
                       ;    return NULL;
 0483 CC0000            ldd #0
 0486 8F                xgdx
 0487 C30004            addd #4
 048A 8F                xgdx
 048B 35                txs
 048C 38                pulx
 048D 39                rts
 048E                 L64:
 048E 8F                xgdx
 048F C30004            addd #4
 0492 8F                xgdx
 0493 35                txs
 0494 38                pulx
 0495 39                rts
                       ;  IX -> 0,x
                       ;          ?temp -> 2,x
                       ;        payload -> 12,x
                       ;             to -> 9,x
 0496                 _presto_send_message::
 0496 BD0000            jsr __enterb
 0499 46                .byte 0x46
 049A                 kernel.420::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   M E S S A G E S   A N D   T I M E R S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; BYTE presto_send_message(PRESTO_TID_T to, PRESTO_MAIL_T payload) {
                       ;    return presto_timer(to,0,payload);
 049A EC00              ldd 0,x
 049C C30002            addd #2
 049F 1AEE0C            ldy 12,x
 04A2 3C                pshx
 04A3 8F                xgdx
 04A4 CC0004            ldd #4
 04A7 BD0000            jsr __asgnblk
 04AA 38                pulx
 04AB EC00              ldd 0,x
 04AD C30002            addd #2
 04B0 37                pshb
 04B1 36                psha
 04B2 CC0000            ldd #0
 04B5 37                pshb
 04B6 36                psha
 04B7 E609              ldab 9,x
 04B9 4F                clra
 04BA 5D                tstb
 04BB 2A01              bpl X2
 04BD 43                coma
 04BE                 X2:
 04BE BD04DA            jsr _presto_timer
 04C1 1838              puly
 04C3 1838              puly
 04C5 4F                clra
 04C6 8F                xgdx
 04C7 C30006            addd #6
 04CA 8F                xgdx
 04CB 35                txs
 04CC 38                pulx
 04CD 1838              puly
 04CF 39                rts
 04D0                 L70:
 04D0 8F                xgdx
 04D1 C30006            addd #6
 04D4 8F                xgdx
 04D5 35                txs
 04D6 38                pulx
 04D7 1838              puly
 04D9 39                rts
                       ;  IX -> 0,x
                       ;  func temp: 2,x - 6,x
                       ;          ?temp -> 6,x
                       ;          ?temp -> 10,x
                       ;          msg_p -> 14,x
                       ;          ?temp -> 16,x
                       ;          ?temp -> 20,x
                       ;          ?temp -> 24,x
                       ;          ?temp -> 28,x
                       ;        tcb_ptr -> 32,x
                       ;     new_mail_p -> 34,x
                       ;        payload -> 44,x
                       ;          delay -> 42,x
                       ;             to -> 39,x
 04DA                 _presto_timer::
 04DA BD0000            jsr __enterb
 04DD 64                .byte 0x64
 04DE 0F                    sei
 04DF                 kernel.433::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; BYTE presto_timer(PRESTO_TID_T to, unsigned short delay, PRESTO_MAIL_T payload) {
                       ;    PRESTO_MESSAGE_T * new_mail_p;
                       ;    PRESTO_TCB_T * tcb_ptr;
                       ; 
                       ;    // we're going to mess with the PO mail list... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    // check to see if there's room
                       ;    if(free_mail_p==NULL) {
 04DF FC000E            ldd _free_mail_p
 04E2 2603              bne L72
 04E4                 kernel.434::	
                       ;       presto_fatal_error();
 04E4 BD0000            jsr _presto_fatal_error
 04E7                 kernel.435::	
                       ;    }
 04E7                 L72:
 04E7                 kernel.438::	
                       ; 
                       ;    // check to see that the recipient is an alive task
                       ;    tcb_ptr=tid_to_tcbptr(to);
 04E7 E627              ldab 39,x
 04E9 4F                clra
 04EA 5D                tstb
 04EB 2A01              bpl X3
 04ED 43                coma
 04EE                 X3:
 04EE 4F                clra
 04EF BD086C            jsr _tid_to_tcbptr
 04F2 ED20              std 32,x
 04F4                 kernel.439::	
                       ;    if(tcb_ptr==NULL) {
 04F4 EC20              ldd 32,x
 04F6 2603              bne L74
 04F8                 kernel.440::	
                       ;       presto_fatal_error();
 04F8 BD0000            jsr _presto_fatal_error
 04FB                 kernel.441::	
                       ;    }
 04FB                 L74:
 04FB                 kernel.444::	
                       ; 
                       ;    // allocate space for a new message
                       ;    new_mail_p=free_mail_p;
 04FB FC000E            ldd _free_mail_p
 04FE ED22              std 34,x
 0500                 kernel.445::	
                       ;    free_mail_p=free_mail_p->next;
 0500 FC000E            ldd _free_mail_p
 0503 C3000E            addd #14
 0506 188F              xgdy
 0508 18EC00            ldd 0,y
 050B FD000E            std _free_mail_p
 050E                 kernel.449::	
                       ; 
                       ;    // fill in the blanks
                       ;    // new_mail_p->serial_number;   already set
                       ;    new_mail_p->from_tid=current_tcb_p->task_id;
 050E EC22              ldd 34,x
 0510 C30002            addd #2
 0513 188F              xgdy
 0515 183C              pshy ; spill
 0517 18FE0006          ldy _current_tcb_p
 051B 18E600            ldab 0,y
 051E 1838              puly ; reload
 0520 18E700            stab 0,y
 0523                 kernel.450::	
                       ;    new_mail_p->to_tcb_p=tcb_ptr;
 0523 EC22              ldd 34,x
 0525 C30004            addd #4
 0528 188F              xgdy
 052A EC20              ldd 32,x
 052C 18ED00            std 0,y
 052F                 kernel.451::	
                       ;    new_mail_p->delivery_time=clock_add(presto_master_clock,delay);
 052F EC2A              ldd 42,x
 0531 37                pshb
 0532 36                psha
 0533 EC00              ldd 0,x
 0535 C3001C            addd #28
 0538 18CE0175          ldy #_presto_master_clock
 053C 3C                pshx
 053D 8F                xgdx
 053E CC0004            ldd #4
 0541 BD0000            jsr __asgnblk
 0544 38                pulx
 0545 EC00              ldd 0,x
 0547 C3001C            addd #28
 054A 37                pshb
 054B 36                psha
 054C EC00              ldd 0,x
 054E C30018            addd #24
 0551 BD0000            jsr _clock_add
 0554 1838              puly
 0556 1838              puly
 0558 EC00              ldd 0,x
 055A C30018            addd #24
 055D 188F              xgdy
 055F EC22              ldd 34,x
 0561 C30006            addd #6
 0564 3C                pshx
 0565 8F                xgdx
 0566 CC0004            ldd #4
 0569 BD0000            jsr __asgnblk
 056C 38                pulx
 056D                 kernel.452::	
                       ;    new_mail_p->payload=payload;
 056D EC22              ldd 34,x
 056F C3000A            addd #10
 0572 1AEE2C            ldy 44,x
 0575 3C                pshx
 0576 8F                xgdx
 0577 CC0004            ldd #4
 057A BD0000            jsr __asgnblk
 057D 38                pulx
 057E                 kernel.455::	
                       ; 
                       ;    // insert new message into list in time order
                       ;    if(po_mail_p==NULL) {
 057E FC0010            ldd _po_mail_p
 0581 2615              bne L76
 0583                 kernel.458::	
                       ; 
                       ;       // we are the first message in PO
                       ;       po_mail_p=new_mail_p;
 0583 EC22              ldd 34,x
 0585 FD0010            std _po_mail_p
 0588                 kernel.459::	
                       ;       new_mail_p->next=NULL;
 0588 EC22              ldd 34,x
 058A C3000E            addd #14
 058D 188F              xgdy
 058F CC0000            ldd #0
 0592 18ED00            std 0,y
 0595                 kernel.461::	
                       ; 
                       ;    } else if(clock_compare(po_mail_p->delivery_time,new_mail_p->delivery_time)>0) {
 0595 7E068C            jmp L77
 0598                 L76:
 0598 EC00              ldd 0,x
 059A C30014            addd #20
 059D 37                pshb ; 
 059E 36                psha ; spill
 059F EC22              ldd 34,x
 05A1 C30006            addd #6
 05A4 188F              xgdy
 05A6 32                pula ; 
 05A7 33                pulb ; reload
 05A8 3C                pshx
 05A9 8F                xgdx
 05AA CC0004            ldd #4
 05AD BD0000            jsr __asgnblk
 05B0 38                pulx
 05B1 EC00              ldd 0,x
 05B3 C30014            addd #20
 05B6 37                pshb
 05B7 36                psha
 05B8 EC00              ldd 0,x
 05BA C30010            addd #16
 05BD 37                pshb ; 
 05BE 36                psha ; spill
 05BF FC0010            ldd _po_mail_p
 05C2 C30006            addd #6
 05C5 188F              xgdy
 05C7 32                pula ; 
 05C8 33                pulb ; reload
 05C9 3C                pshx
 05CA 8F                xgdx
 05CB CC0004            ldd #4
 05CE BD0000            jsr __asgnblk
 05D1 38                pulx
 05D2 EC00              ldd 0,x
 05D4 C30010            addd #16
 05D7 BD0000            jsr _clock_compare
 05DA 1838              puly
 05DC ED02              std 2,x
 05DE 6D03              tst 3,x
 05E0 2F15              ble L78
 05E2                 kernel.464::	
                       ; 
                       ;       // advance to the head of the class!
                       ;       new_mail_p->next=po_mail_p;
 05E2 EC22              ldd 34,x
 05E4 C3000E            addd #14
 05E7 188F              xgdy
 05E9 FC0010            ldd _po_mail_p
 05EC 18ED00            std 0,y
 05EF                 kernel.465::	
                       ;       po_mail_p=new_mail_p;
 05EF EC22              ldd 34,x
 05F1 FD0010            std _po_mail_p
 05F4                 kernel.467::	
                       ; 
                       ;    } else {
 05F4 7E068C            jmp L79
 05F7                 L78:
 05F7                 kernel.470::	
                       ; 
                       ;       // we are one of many messages in the PO
                       ;       PRESTO_MESSAGE_T * msg_p=po_mail_p;
 05F7 FC0010            ldd _po_mail_p
 05FA ED0E              std 14,x
 05FC 205B              bra L81
 05FE                 L80:
 05FE                 kernel.472::	
                       ;       while(msg_p->next!=NULL) {
                       ;          if(clock_compare(msg_p->next->delivery_time,new_mail_p->delivery_time)>0) break;
 05FE EC00              ldd 0,x
 0600 C3000A            addd #10
 0603 37                pshb ; 
 0604 36                psha ; spill
 0605 EC22              ldd 34,x
 0607 C30006            addd #6
 060A 188F              xgdy
 060C 32                pula ; 
 060D 33                pulb ; reload
 060E 3C                pshx
 060F 8F                xgdx
 0610 CC0004            ldd #4
 0613 BD0000            jsr __asgnblk
 0616 38                pulx
 0617 EC00              ldd 0,x
 0619 C3000A            addd #10
 061C 37                pshb
 061D 36                psha
 061E EC0E              ldd 14,x
 0620 C3000E            addd #14
 0623 188F              xgdy
 0625 18EC00            ldd 0,y
 0628 C30006            addd #6
 062B 188F              xgdy
 062D EC00              ldd 0,x
 062F C30006            addd #6
 0632 3C                pshx
 0633 8F                xgdx
 0634 CC0004            ldd #4
 0637 BD0000            jsr __asgnblk
 063A 38                pulx
 063B EC00              ldd 0,x
 063D C30006            addd #6
 0640 BD0000            jsr _clock_compare
 0643 1838              puly
 0645 ED04              std 4,x
 0647 6D05              tst 5,x
 0649 2F02              ble L83
 064B 201B              bra L82
 064D                 L83:
 064D                 kernel.473::	
                       ;          msg_p=msg_p->next;
 064D EC0E              ldd 14,x
 064F C3000E            addd #14
 0652 188F              xgdy
 0654 18EC00            ldd 0,y
 0657 ED0E              std 14,x
 0659                 kernel.474::	
                       ;       }
 0659                 L81:
 0659 EC0E              ldd 14,x
 065B C3000E            addd #14
 065E 188F              xgdy
 0660 18EC00            ldd 0,y
 0663 2703              beq X4
 0665 7E05FE            jmp L80
 0668                 X4:
 0668                 L82:
 0668                 kernel.478::	
                       ; 
                       ;       // msg_p->next is either NULL or later delivery time than us
                       ;       // either way, we want to get inserted between msg_p and msg_p->next
                       ;       new_mail_p->next=msg_p->next;
 0668 EC0E              ldd 14,x
 066A C3000E            addd #14
 066D 188F              xgdy
 066F 18EC00            ldd 0,y
 0672 37                pshb ; 
 0673 36                psha ; spill
 0674 EC22              ldd 34,x
 0676 C3000E            addd #14
 0679 188F              xgdy
 067B 32                pula ; 
 067C 33                pulb ; reload
 067D 18ED00            std 0,y
 0680                 kernel.479::	
                       ;       msg_p->next=new_mail_p;
 0680 EC0E              ldd 14,x
 0682 C3000E            addd #14
 0685 188F              xgdy
 0687 EC22              ldd 34,x
 0689 18ED00            std 0,y
 068C                 kernel.480::	
                       ;    }
 068C                 L79:
 068C                 L77:
 068C 0E                    cli
 068D                 kernel.485::	
                       ; 
                       ;    // we're done messing with the PO mail list... interrupts back on
                       ;    INTR_ON();
                       ; 
                       ;    return 0;
 068D CC0000            ldd #0
 0690 8F                xgdx
 0691 C30024            addd #36
 0694 8F                xgdx
 0695 35                txs
 0696 38                pulx
 0697 1838              puly
 0699 39                rts
 069A                 L71:
 069A 8F                xgdx
 069B C30024            addd #36
 069E 8F                xgdx
 069F 35                txs
 06A0 38                pulx
 06A1 1838              puly
 06A3 39                rts
                       ;  IX -> 0,x
                       ;          msg_p -> 2,x
                       ;      payload_p -> 6,x
 06A4                 _presto_wait_for_message::
 06A4 BD0000            jsr __enterb
 06A7 44                .byte 0x44
 06A8 0F                    sei
 06A9                 kernel.497::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; BYTE presto_wait_for_message(PRESTO_MAIL_T * payload_p) {
                       ;    PRESTO_MESSAGE_T * msg_p;
                       ; 
                       ;    // we're about to switch to a new task... interrupts off
                       ;    INTR_OFF();
                       ; 
                       ;    // we will only sleep if there are no messages in our queue
                       ;    if(current_tcb_p->mailbox_head==NULL) {
 06A9 FC0006            ldd _current_tcb_p
 06AC C3000E            addd #14
 06AF 188F              xgdy
 06B1 18EC00            ldd 0,y
 06B4 260F              bne L86
 06B6                 kernel.499::	
                       ;       // no mail, so we can sleep
                       ;       current_tcb_p->state=STATE_BLOCKED;
 06B6 FC0006            ldd _current_tcb_p
 06B9 C3000A            addd #10
 06BC 188F              xgdy
 06BE CC0001            ldd #1
 06C1 18ED00            std 0,y
 06C4 3F                swi
 06C5                 kernel.503::	
                       ;       asm("swi");
                       ;       // When we wake up, we'll be ready to recieve our mail.
                       ;       // Interrupts will be enabled.
                       ;    }
 06C5                 L86:
 06C5 0F                    sei
 06C6                 kernel.508::	
                       ; 
                       ;    // we're about to mess with the mail list... interrupts off
                       ;    INTR_OFF();
                       ;    // we're going to use this a lot, so dereference now
                       ;    msg_p=current_tcb_p->mailbox_head;
 06C6 FC0006            ldd _current_tcb_p
 06C9 C3000E            addd #14
 06CC 188F              xgdy
 06CE 18EC00            ldd 0,y
 06D1 ED02              std 2,x
 06D3                 kernel.511::	
                       ; 
                       ;    // get one message from the task's mail queue
                       ;    if(msg_p==NULL) {
 06D3 EC02              ldd 2,x
 06D5 2603              bne L88
 06D7                 kernel.513::	
                       ;       // there are no messages in the task's mail list
                       ;       presto_fatal_error();
 06D7 BD0000            jsr _presto_fatal_error
 06DA                 kernel.514::	
                       ;    }
 06DA                 L88:
 06DA                 kernel.517::	
                       ; 
                       ;    // are we being paranoid?
                       ;    if((msg_p->to_tcb_p)!=current_tcb_p) {
 06DA EC02              ldd 2,x
 06DC C30004            addd #4
 06DF 188F              xgdy
 06E1 18EC00            ldd 0,y
 06E4 1AB30006          cpd _current_tcb_p
 06E8 2703              beq L90
 06EA                 kernel.518::	
                       ;       presto_fatal_error();
 06EA BD0000            jsr _presto_fatal_error
 06ED                 kernel.519::	
                       ;    }
 06ED                 L90:
 06ED                 kernel.522::	
                       ; 
                       ;    // there is at least one message, get one
                       ;    if (msg_p==current_tcb_p->mailbox_tail) {
 06ED FC0006            ldd _current_tcb_p
 06F0 C30010            addd #16
 06F3 188F              xgdy
 06F5 EC02              ldd 2,x
 06F7 CDA300            cpd 0,y
 06FA 261E              bne L92
 06FC                 kernel.524::	
                       ;       // there is only one item in the list, take it
                       ;       current_tcb_p->mailbox_head=NULL;
 06FC FC0006            ldd _current_tcb_p
 06FF C3000E            addd #14
 0702 188F              xgdy
 0704 CC0000            ldd #0
 0707 18ED00            std 0,y
 070A                 kernel.525::	
                       ;       current_tcb_p->mailbox_tail=NULL;
 070A FC0006            ldd _current_tcb_p
 070D C30010            addd #16
 0710 188F              xgdy
 0712 CC0000            ldd #0
 0715 18ED00            std 0,y
 0718                 kernel.526::	
                       ;    } else {
 0718 2019              bra L93
 071A                 L92:
 071A                 kernel.528::	
                       ;       // there are many messages, take first
                       ;       current_tcb_p->mailbox_head=msg_p->next;
 071A EC02              ldd 2,x
 071C C3000E            addd #14
 071F 188F              xgdy
 0721 18EC00            ldd 0,y
 0724 37                pshb ; 
 0725 36                psha ; spill
 0726 FC0006            ldd _current_tcb_p
 0729 C3000E            addd #14
 072C 188F              xgdy
 072E 32                pula ; 
 072F 33                pulb ; reload
 0730 18ED00            std 0,y
 0733                 kernel.529::	
                       ;    }
 0733                 L93:
 0733                 kernel.532::	
                       ; 
                       ;    // record the message id before we can get interrupted
                       ;    if(payload_p!=NULL) *payload_p=msg_p->payload;
 0733 EC06              ldd 6,x
 0735 2712              beq L94
 0737 EC02              ldd 2,x
 0739 C3000A            addd #10
 073C 188F              xgdy
 073E EC06              ldd 6,x
 0740 3C                pshx
 0741 8F                xgdx
 0742 CC0004            ldd #4
 0745 BD0000            jsr __asgnblk
 0748 38                pulx
 0749                 L94:
 0749                 kernel.535::	
                       ; 
                       ;    // return the message to the free list
                       ;    msg_p->next=free_mail_p;
 0749 EC02              ldd 2,x
 074B C3000E            addd #14
 074E 188F              xgdy
 0750 FC000E            ldd _free_mail_p
 0753 18ED00            std 0,y
 0756                 kernel.536::	
                       ;    free_mail_p=msg_p;
 0756 EC02              ldd 2,x
 0758 FD000E            std _free_mail_p
 075B 0E                    cli
 075C                 kernel.542::	
                       ; 
                       ;    // done messing with mail lists... interrupts back on
                       ;    INTR_ON();
                       ; 
                       ;    // return the number of messages retrieved
                       ;    return 1;
 075C CC0001            ldd #1
 075F 8F                xgdx
 0760 C30004            addd #4
 0763 8F                xgdx
 0764 35                txs
 0765 38                pulx
 0766 1838              puly
 0768 39                rts
 0769                 L85:
 0769 8F                xgdx
 076A C30004            addd #4
 076D 8F                xgdx
 076E 35                txs
 076F 38                pulx
 0770 1838              puly
 0772 39                rts
                       ;  IX -> 0,x
                       ;  func temp: 2,x - 4,x
                       ;          ?temp -> 4,x
                       ;          ?temp -> 8,x
                       ;          count -> 13,x
                       ;          msg_p -> 14,x
                       ;          tcb_p -> 16,x
 0773                 _deliver_mail::
 0773 BD0000            jsr __enterb
 0776 12                .byte 0x12
 0777                 kernel.548::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ BYTE deliver_mail(void) {
                       ;    BYTE count=0;
 0777 6F0D              clr 13,x
 0779 7E080B            jmp L98
 077C                 L97:
 077C                 kernel.553::	
                       ;    PRESTO_MESSAGE_T * msg_p;
                       ;    PRESTO_TCB_T * tcb_p;
                       ;    while((po_mail_p!=NULL)&&(clock_compare(po_mail_p->delivery_time,presto_master_clock)<=0)) {
                       ;       // we're going to use this a lot, so de-reference once
                       ;       tcb_p=po_mail_p->to_tcb_p;
 077C FC0010            ldd _po_mail_p
 077F C30004            addd #4
 0782 188F              xgdy
 0784 18EC00            ldd 0,y
 0787 ED10              std 16,x
 0789                 kernel.554::	
                       ;       if(tcb_p==NULL) presto_fatal_error();
 0789 EC10              ldd 16,x
 078B 2603              bne L100
 078D BD0000            jsr _presto_fatal_error
 0790                 L100:
 0790                 kernel.557::	
                       ; 
                       ;       // make receiver task ready
                       ;       tcb_p->state=STATE_READY;
 0790 EC10              ldd 16,x
 0792 C3000A            addd #10
 0795 188F              xgdy
 0797 CC0000            ldd #0
 079A 18ED00            std 0,y
 079D                 kernel.560::	
                       ; 
                       ;       // remove message from PO list
                       ;       msg_p=po_mail_p;
 079D FC0010            ldd _po_mail_p
 07A0 ED0E              std 14,x
 07A2                 kernel.561::	
                       ;       po_mail_p=po_mail_p->next;
 07A2 FC0010            ldd _po_mail_p
 07A5 C3000E            addd #14
 07A8 188F              xgdy
 07AA 18EC00            ldd 0,y
 07AD FD0010            std _po_mail_p
 07B0                 kernel.564::	
                       ; 
                       ;       // move the message to the task's mail list
                       ;       if(tcb_p->mailbox_head==NULL) {
 07B0 EC10              ldd 16,x
 07B2 C3000E            addd #14
 07B5 188F              xgdy
 07B7 18EC00            ldd 0,y
 07BA 261A              bne L102
 07BC                 kernel.567::	
                       ; 
                       ;          // we are the only message in the list
                       ;          tcb_p->mailbox_head=msg_p;
 07BC EC10              ldd 16,x
 07BE C3000E            addd #14
 07C1 188F              xgdy
 07C3 EC0E              ldd 14,x
 07C5 18ED00            std 0,y
 07C8                 kernel.568::	
                       ;          tcb_p->mailbox_tail=msg_p;
 07C8 EC10              ldd 16,x
 07CA C30010            addd #16
 07CD 188F              xgdy
 07CF EC0E              ldd 14,x
 07D1 18ED00            std 0,y
 07D4                 kernel.570::	
                       ; 
                       ;       } else {
 07D4 2020              bra L103
 07D6                 L102:
 07D6                 kernel.573::	
                       ; 
                       ;          // we are one of many, add to the tail of the list
                       ;          tcb_p->mailbox_tail->next=msg_p;
 07D6 EC10              ldd 16,x
 07D8 C30010            addd #16
 07DB 188F              xgdy
 07DD 18EC00            ldd 0,y
 07E0 C3000E            addd #14
 07E3 188F              xgdy
 07E5 EC0E              ldd 14,x
 07E7 18ED00            std 0,y
 07EA                 kernel.574::	
                       ;          tcb_p->mailbox_tail=msg_p;
 07EA EC10              ldd 16,x
 07EC C30010            addd #16
 07EF 188F              xgdy
 07F1 EC0E              ldd 14,x
 07F3 18ED00            std 0,y
 07F6                 kernel.576::	
                       ; 
                       ;       }
 07F6                 L103:
 07F6                 kernel.578::	
                       ;       // no matter what, we are the last in the task's message list
                       ;       msg_p->next=NULL;
 07F6 EC0E              ldd 14,x
 07F8 C3000E            addd #14
 07FB 188F              xgdy
 07FD CC0000            ldd #0
 0800 18ED00            std 0,y
 0803                 kernel.581::	
                       ; 
                       ;       // indicate that we moved one mail message
                       ;       count++;
 0803 E60D              ldab 13,x
 0805 4F                clra
 0806 C30001            addd #1
 0809 E70D              stab 13,x
 080B                 kernel.582::	
                       ;    }
 080B                 L98:
 080B FC0010            ldd _po_mail_p
 080E 2746              beq L104
 0810 EC00              ldd 0,x
 0812 C30008            addd #8
 0815 18CE0175          ldy #_presto_master_clock
 0819 3C                pshx
 081A 8F                xgdx
 081B CC0004            ldd #4
 081E BD0000            jsr __asgnblk
 0821 38                pulx
 0822 EC00              ldd 0,x
 0824 C30008            addd #8
 0827 37                pshb
 0828 36                psha
 0829 EC00              ldd 0,x
 082B C30004            addd #4
 082E 37                pshb ; 
 082F 36                psha ; spill
 0830 FC0010            ldd _po_mail_p
 0833 C30006            addd #6
 0836 188F              xgdy
 0838 32                pula ; 
 0839 33                pulb ; reload
 083A 3C                pshx
 083B 8F                xgdx
 083C CC0004            ldd #4
 083F BD0000            jsr __asgnblk
 0842 38                pulx
 0843 EC00              ldd 0,x
 0845 C30004            addd #4
 0848 BD0000            jsr _clock_compare
 084B 1838              puly
 084D ED02              std 2,x
 084F 6D03              tst 3,x
 0851 2E03              bgt X5
 0853 7E077C            jmp L97
 0856                 X5:
 0856                 L104:
 0856                 kernel.583::	
                       ;    return count;
 0856 E60D              ldab 13,x
 0858 4F                clra
 0859 8F                xgdx
 085A C30012            addd #18
 085D 8F                xgdx
 085E 35                txs
 085F 38                pulx
 0860 39                rts
 0861                 L96:
 0861 8F                xgdx
 0862 C30012            addd #18
 0865 8F                xgdx
 0866 35                txs
 0867 38                pulx
 0868 39                rts
                       ;  IX -> 0,x
 0869                 _idle_task::
 0869                 kernel.590::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   I D L E   T A S K
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ void idle_task(void) {
 0869                 L106:
 0869                 kernel.593::	
                       ;    while(1) {
                       ;       // do nothing
                       ;    }
 0869                 L107:
 0869 20FE              bra L106
 086B                 L105:
 086B 39                rts
                       ;  IX -> 0,x
                       ;            tid -> 5,x
 086C                 _tid_to_tcbptr::
 086C 37                pshb
 086D 36                psha
 086E 3C                pshx
 086F 30                tsx
 0870 3C                pshx
 0871 30                tsx
 0872 EC04              ldd 4,x
 0874 E705              stab 5,x
 0876                 kernel.601::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   U T I L I T I E S
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ PRESTO_TCB_T * tid_to_tcbptr(BYTE tid) {
                       ;    if(tid>=MAX_TASKS) presto_fatal_error();
 0876 E605              ldab 5,x
 0878 C106              cmpb #6
 087A 2503              blo L110
 087C BD0000            jsr _presto_fatal_error
 087F                 L110:
 087F                 kernel.602::	
                       ;    if(tcb_list[tid].state==STATE_INACTIVE) return NULL;
 087F E605              ldab 5,x
 0881 4F                clra
 0882 188F              xgdy
 0884 CC0012            ldd #18
 0887 BD0000            jsr __muli
 088A C30183            addd #_tcb_list+10
 088D 188F              xgdy
 088F 18EC00            ldd 0,y
 0892 1A830002          cpd #2
 0896 260D              bne L112
 0898 CC0000            ldd #0
 089B 8F                xgdx
 089C C30002            addd #2
 089F 8F                xgdx
 08A0 35                txs
 08A1 38                pulx
 08A2 1838              puly
 08A4 39                rts
 08A5                 L112:
 08A5                 kernel.603::	
                       ;    return &tcb_list[tid];
 08A5 E605              ldab 5,x
 08A7 4F                clra
 08A8 188F              xgdy
 08AA CC0012            ldd #18
 08AD BD0000            jsr __muli
 08B0 C30179            addd #_tcb_list
 08B3 8F                xgdx
 08B4 C30002            addd #2
 08B7 8F                xgdx
 08B8 35                txs
 08B9 38                pulx
 08BA 1838              puly
 08BC 39                rts
 08BD                 L109:
 08BD 8F                xgdx
 08BE C30002            addd #2
 08C1 8F                xgdx
 08C2 35                txs
 08C3 38                pulx
 08C4 1838              puly
 08C6 39                rts
                       ;  IX -> 0,x
                       ;  rMEM -> 2,x
 08C7                 _presto_start_master_timer::
 08C7 BD0000            jsr __enterb
 08CA 04                .byte 0x4
 08CB                 kernel.612::	
                       ; }
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; //   H A R D W A R E   T I M E R / C O U N T E R
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ void presto_start_master_timer(void) {
                       ;    // store (current plus CYCLES_PER_TICK)
                       ;    TOC2 = TCNT + CYCLES_PER_TICK;
 08CB CC07D0            ldd #2000
 08CE 18CE0064          ldy #100
 08D2 BD0000            jsr __muli
 08D5 ED02              std 2,x
 08D7 FC100E            ldd 0x100e ; vol
 08DA E302              addd 2,x
 08DC FD1018            std 0x1018
 08DF                 kernel.614::	
                       ;    // request output compare interrupt
                       ;    TMSK1 |= TMSK1_OC2I;
 08DF 18CE1022          ldy #0x1022
 08E3 181C0040          bset 0,y,#64
 08E7                 kernel.617::	
                       ;    // clear the OUTPUT COMPARE flag
                       ;    // writing O's makes no change, writing 1's clears the bit
                       ;    TFLG1 = TFLG1_OC2F;
 08E7 C640              ldab #64
 08E9 F71023            stab 0x1023
 08EC                 kernel.619::	
                       ;    // counter disconnected from output pin logic
                       ;    TCTL1 &= ~(TCTL1_OM2|TCTL1_OL2);
 08EC 18CE1020          ldy #0x1020
 08F0 181D00C0          bclr 0,y,~#-193
 08F4                 kernel.620::	
                       ; }
 08F4                 L115:
 08F4 8F                xgdx
 08F5 C30004            addd #4
 08F8 8F                xgdx
 08F9 35                txs
 08FA 38                pulx
 08FB 39                rts
                       ;  IX -> 0,x
                       ;  rMEM -> 2,x
 08FC                 _presto_restart_master_timer::
 08FC BD0000            jsr __enterb
 08FF 04                .byte 0x4
 0900                 kernel.626::	
                       ; 
                       ; ////////////////////////////////////////////////////////////////////////////////
                       ; 
                       ; /*static*/ void presto_restart_master_timer(void) {
                       ;    // store (last plus CYCLES_PER_TICK)
                       ;    TOC2 = TOC2 + CYCLES_PER_TICK;
 0900 CC07D0            ldd #2000
 0903 18CE0064          ldy #100
 0907 BD0000            jsr __muli
 090A ED02              std 2,x
 090C FC1018            ldd 0x1018 ; vol
 090F E302              addd 2,x
 0911 FD1018            std 0x1018
 0914                 kernel.629::	
                       ;    // clear the OUTPUT COMPARE flag
                       ;    // writing O's makes no change, writing 1's clears the bit
                       ;    TFLG1 = TFLG1_OC2F;
 0914 C640              ldab #64
 0916 F71023            stab 0x1023
 0919                 kernel.630::	
                       ; }
 0919                 L116:
 0919 8F                xgdx
 091A C30004            addd #4
 091D 8F                xgdx
 091E 35                txs
 091F 38                pulx
 0920 39                rts
                         .area bss
 0000                 _mail_list::
 0000                   .blkb 320
 0140                 _idle_tid::
 0140                   .blkb 1
 0141                 _idle_tcb_p::
 0141                   .blkb 2
 0143                 _idle_stack::
 0143                   .blkb 50
 0175                 _presto_master_clock::
 0175                   .blkb 4
 0179                 _tcb_list::
 0179                   .blkb 108
 01E5                 _global_save_sp::
 01E5                   .blkb 2
