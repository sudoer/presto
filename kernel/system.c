////////////////////////////////////////////////////////////////////////////////
//   C O M M E N T A R Y
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   D E P E N D E N C I E S
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   C O N S T A N T S
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   D A T A   T Y P E S
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   S T A T I C   G L O B A L   D A T A
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   S T A T I C   F U N C T I O N   P R O T O T Y P E S
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   E X P O R T E D   F U N C T I O N S
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//   S T A T I C   F U N C T I O N S
////////////////////////////////////////////////////////////////////////////////

#include "hc11regs.h"
#include "system.h"
#include "kernel\kernel.h"
#include "services\serial.h"
#include "services\motors.h"
#include "services\sound.h"

#ifdef ICC
   extern void _start();   // entry point in crt11.s
#endif

////////////////////////////////////////////////////////////////////////////////

// This function is called from the startup (crt11.s) before interrupts have
// been turned on but after the stack has been set up.

void _HC11Setup() {

   INTR_OFF();

   // request output compare interrupt for TOC1,TOC2,TOC3
   TMSK1=0x00;   // not yet ... TMSK1_OC1I | TMSK1_OC2I | TMSK1_OC3I;

   // set prescaler for timer to 1
   // disable TOF, RTIF, PAOVF, PAIF interrupts
   TMSK2=0x00;

   // disable SECURITY and COP, disable ROM and EEPROM
   CONFIG=0x0C;

   // turn on the A2D subsystem (wait 100 usec before using)
   // use "E clock" to drive the A2D
   OPTION=0xA0;  // OPTION_ADPU=1,OPTION_CSEL=0

   INTR_ON();
}

////////////////////////////////////////////////////////////////////////////////

#pragma interrupt inert_isr
void inert_isr(void) {
}

////////////////////////////////////////////////////////////////////////////////

#pragma interrupt presto_swi
void presto_swi(void) {
   presto_fatal_error();
}

////////////////////////////////////////////////////////////////////////////////

// address FFD6 for simulator
// address BFD6 for handyboard

#pragma abs_address:0xBFD6
static void (*special_interrupt_vectors[])() = {
   inert_isr,   // SCI    -   presto_serial_isr
   inert_isr,   // SPI
   inert_isr,   // PAIE
   inert_isr,   // PAO
   inert_isr,   // TOF
   inert_isr,   // TOC5
   inert_isr,   // TOC4
   inert_isr,   // TOC3   -   motor_isr
   inert_isr,   // TOC2   -   presto_system_isr
   inert_isr,   // TOC1
   inert_isr,   // TIC3
   inert_isr,   // TIC2
   inert_isr,   // TIC1
   inert_isr,   // RTI
   inert_isr,   // IRQ
   inert_isr,   // XIRQ
   presto_swi,  // SWI
   inert_isr,   // ILLOP
   inert_isr,   // COP
   inert_isr,   // CLM
   _start       // RESET
};
#pragma end_abs_address

////////////////////////////////////////////////////////////////////////////////

//extern void os_set_irq(int number, void (*fn)() );
void set_interrupt(BYTE intr, void (*vector)(void)) {
   if(intr<=INTR_RESET) {
      special_interrupt_vectors[intr]=vector;
   }
}

////////////////////////////////////////////////////////////////////////////////
//   S A F E T Y   C H E C K
////////////////////////////////////////////////////////////////////////////////

// this is the memory location for the motor controller
#define ERROR_PORT *(unsigned char *)(0x7FFF)

void presto_fatal_error(void) {
   // should never get here
   BYTE delay;
   INTR_OFF();

   // speaker is always an output
   BITSET(DDRD,4);              // LED is an output
   while(1) {
      // toggle speaker
      BITNOT(PORTA,3);
      // LED on
      BITCLR(PORTD,4);
      // delay
      while(--delay>0) {
         // This will force the motor lights to blink so fast
         // that all eight of them will appear to be on.
         ERROR_PORT=delay;
      }
   }
}

////////////////////////////////////////////////////////////////////////////////

